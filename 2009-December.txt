From alerios at mail.berlios.de  Mon Dec 14 23:25:56 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Mon, 14 Dec 2009 23:25:56 +0100
Subject: [Destar-dev] r837 - trunk
Message-ID: <200912142225.nBEMPu1V019000@sheep.berlios.de>

Author: alerios
Date: 2009-12-14 23:25:56 +0100 (Mon, 14 Dec 2009)
New Revision: 837

Added:
   trunk/page_stats_agents.ptl
Modified:
   trunk/CHANGELOG.txt
   trunk/page_stats.ptl
   trunk/page_stats_calls.ptl
   trunk/page_stats_cdr.ptl
   trunk/page_stats_dialouts.ptl
   trunk/page_stats_phone.ptl
   trunk/page_stats_queue.ptl
   trunk/page_stats_trunks.ptl
Log:
* page_stats_*.ptl: set _q_level = 2
* Added page_stats_agents.ptl
* Added TRANSFER query on page_stats_queue.ptl



Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/CHANGELOG.txt	2009-12-14 22:25:56 UTC (rev 837)
@@ -1,3 +1,15 @@
+2009-12-14
+* page_stats_*.ptl: set _q_level = 2
+* Added page_stats_agents.ptl
+* Added TRANSFER query on page_stats_queue.ptl
+
+2009-04-16
+* Zap -> DAHDI changes from branch icom-avatar
+* Manager API 1.1 (from branch icom-avatar). This only works on Asterisk 1.6
+With this reload will fail on Asterisk < 1.6.0
+* If a module fails to load: warn. Don't Panic.
+* A first shot at Asterisk 1.6 compatibility: s/|/,/
+
 2007-11-27
 * Added password field to Cfg Record.
 * Fixed typo in cfg_trunk_zapdynamic.py

Modified: trunk/page_stats.ptl
===================================================================
--- trunk/page_stats.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -28,7 +28,7 @@
 	_q_title   = _("Statistics")
 	_q_desc    = _("Global PBX statistics and CDR")
 	_q_menupos = 20
-	_q_level   = 3
+	_q_level   = 2
 
 	_q_exports = ['']
 

Added: trunk/page_stats_agents.ptl
===================================================================
--- trunk/page_stats_agents.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats_agents.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -0,0 +1,330 @@
+# -*- coding: iso-8859-1 -*-
+#
+# Copyright (C) 2005 Holger Schurig
+# Copyright (C) 2005 Manuel Alejandro Cer?n Estrada <ceronman at gmail.com>
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+# ToDo:
+# - improve the appearance and usability
+# - show the "navigation" buttons only when they are needed
+# - use the current date in the "To:" option
+# - glosary of the CDR terms, see README.cdr of asterisk
+
+# - improve the code and change the name of some variable
+# - ...
+
+
+from Templates import *
+from quixote.form import *
+from quixote.directory import Directory, AccessControlled
+from quixote import get_request, get_session
+import queueutils
+import time
+
+def M_(message): return _(str(message))
+
+def N_(message): return message
+
+def getQueues():
+	import configlets
+	objs = configlets.configlet_tree.getConfigletsByName('CfgPhoneQueue')
+	queues=[]
+	queues.append(N_("All"))
+	for obj in objs:
+		queues.append(obj.name)		
+	return queues
+
+
+def formScript [html] ():
+	'<script language="JavaScript" type="text/javascript"> \n'
+	'<!-- \n'
+	'function gotopage ( page ) \n'
+	'{ \n'
+	'  document.searchform.pagenumber.value = page; \n'
+	'  document.searchform.submit() ; \n'
+	'} \n'
+	'function orderby ( column, order ) \n'
+	'{ \n'
+	'  document.searchform.orderby.value = column; \n'
+	'  document.searchform.order.value = order; \n'
+	'  document.searchform.submit() ; \n'
+	'} \n'
+	'--> \n'
+	'</script> \n'
+
+def pageIndex [html] (pagenum, total, limit):
+	"<p>"
+	if limit == 0:
+		limit=1
+
+	lastpage = total/limit
+
+	if pagenum > 1:
+		"<a href='javascript:gotopage(\"_newest\")'>%s</a> &nbsp; \n" % M_("First")
+		"<a href='javascript:gotopage(\"_newer\")'>%s</a> &nbsp; \n" % M_("Previous")
+	
+	pagelist = [i for i in range(pagenum-10, pagenum+10) if i >= 0 and  i < lastpage]
+
+	for i in pagelist:
+		if pagenum != (i+1):
+			"<a href='javascript:gotopage(\"%d\")'>%d</a> &nbsp; \n" % (i+1, i+1)
+		else:
+			"%d &nbsp; \n" % (i+1)
+
+	if pagenum < lastpage:
+		"<a href='javascript:gotopage(\"_older\")'>%s</a> &nbsp; \n" % M_("Next")
+		"<a href='javascript:gotopage(\"_oldest\")'>%s</a> \n" % M_("Last")
+	"</p>\n <br />"
+
+def     generateYearsNumbers():
+        years = range(2004,time.localtime()[0]+1)
+        return years
+
+def	generateMonthsNumbers():
+	months = range(1,13)
+	for i in range(0,9) :
+		months[i] = "0%s" % months[i]
+	return months
+
+def	generateDaysNumbers():
+	days = range(1,32)
+	for i in range(0,9) :
+		days[i] = "0%s" % days[i]
+	return days
+	
+def 	generateOptionSelect(text=False):
+	option = range (0,110,10)
+	if text:
+		option[0]=_("All")
+	return option
+
+	
+operands=['=','<>','<=','<','>=','>']
+	
+def cdrForm [plain] (request, srcextension="", dstextension="", mincost="", duration="", clid="", pbx=""):
+
+	monthsnumbers = [ '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12' ]
+	monthsnames = [ _('January'), _('February'), _('March'), _('April'), _('May'), _('June'), _('July'), _('August'), _('September'), _('October'), _('November'), _('December') ]
+
+	localtime = time.localtime()
+	
+	localyear = localtime[0]
+	
+	# fix the month value for those smaller than 10 (january ... september) 1 -> 01, 2 ->02 
+	if localtime[1] < 10:
+		localmonth = '0%s' % localtime[1] 
+	else:
+		localmonth = localtime[1]
+	
+	#the same for the day
+	if localtime[2] < 10:
+		localday = '0%s' % localtime[2]
+	else:
+		localday = localtime[2]
+
+	form = Form(name = "searchform")
+	form.add(StringWidget, "agent",  
+					title=htmltext(_("Agent")),
+					hint=htmltext(_("Wildcards: % is the 'zero or more characters' wildcard, and _ is the 'exactly one character' wildcard")),
+					render_br=True )
+
+	form.add_single_select('queue', 
+							title=htmltext(_('Queue:')),
+							value="",
+							options=zip(getQueues(),getQueues(),getQueues()),
+							render_br=True )
+
+	form.add(OptionSelectWidget,'linesToShow', title=_('Number of records to show:'),options=zip( generateOptionSelect(), generateOptionSelect(text=True), generateOptionSelect() ), value=20)	
+	form.add_checkbox('searchBetweenDates',title= _("Search between the following dates"), render_br=True)
+	form.add_single_select('fromyear', title=htmltext(_('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start:')), value="", options=zip( generateYearsNumbers(), generateYearsNumbers() ), render_br=False )
+	form.add_single_select('frommonth', options=zip( generateMonthsNumbers(), monthsnames, generateMonthsNumbers() ), render_br=False )
+	form.add_single_select('fromday', options=zip( generateDaysNumbers() , range(1,32), generateDaysNumbers() ), render_br=True )
+	form.add_single_select('toyear', value=localyear, title=htmltext(_('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End:')), options=zip( generateYearsNumbers(), generateYearsNumbers() ), render_br=False)
+	form.add_single_select('tomonth', value=localmonth, options=zip( generateMonthsNumbers(), monthsnames, generateMonthsNumbers() ), render_br=False)
+	form.add_single_select('today', value=localday, options=zip( generateDaysNumbers() , range(1,32), generateDaysNumbers()  ), render_br=True)
+		
+	form.add(HiddenWidget, 'pagenumber', value='_newest')
+	form.add(HiddenWidget, 'order', value='DESC')
+	form.add(HiddenWidget, 'orderby', value='timestamp')
+
+	form.add(SubmitWidget, '_submit', _("Search"), render_br=True)
+
+	where = []
+	
+	def render [html] ():
+
+		name = form['pagenumber']
+		
+		global pagenum
+
+		if not name in ['_newest','_newer', '_older', '_oldest']:
+			pagenum = int(name)
+
+		cursor = queueutils.count(where = where)
+		total = cursor
+
+		global q
+		global p
+
+		p = form["linesToShow"]
+
+		if p == 0:
+			p = total
+		
+		if (name == True or name == '1' or name == '_newest'):
+			pagenum = 1
+			q = 0
+	
+		elif name == '_newer': 
+			pagenum -= 1
+			q = q-form["linesToShow"]
+			if q < 0:
+				q=0
+							
+					
+		elif name == '_older': 
+			pagenum += 1
+			q += p
+			if q >= total:
+				q = total - total % p
+		
+		elif name == '_oldest':
+			q = total - total % p
+			pagenum = total / p
+
+		elif name in [str(x+1) for x in range(total/p)]:
+			q = int(name) * p
+			
+			if q >= total:
+				q = total - total % p
+			
+		elif p == total:
+			q = 0
+		else : 
+			p = 20
+			q = 0
+				
+		form.render()
+		pageIndex(pagenum, total, p)
+		cdrShowResults(where, p, q, total,form["orderby"],form["order"])
+
+	if not form.is_submitted() or form.has_errors():
+		return render()
+	
+	all = N_("All")
+	if form["queue"] != all:
+		where.append("qname = '%s'" %form["queue"])
+	
+	if form["agent"]:
+		where.append("agent like '%%%s%%'" % form["agent"])
+		where.append("(action like 'COMPLETE%' or action like 'TRANSFER')")
+				
+	if form["searchBetweenDates"]:
+	
+		fromdate = "%s-%s-%s" % (form["fromyear"], form["frommonth"], form["fromday"])
+		todate = "%s-%s-%s" % (form["toyear"], form["tomonth"], form["today"])
+		where.append("date(timestamp) between date('%s') and date('%s')" % (fromdate, todate))
+	
+	return render()
+
+def	cdrShowResults [html] (where=[], limit, offset, total = 0, field="start", order="DESC"):
+	if total == 0:
+		'<p>'
+		'--No records to Show--'
+		'</p>'
+	else:
+		orderby = '%s %s' % (N_(field), order)	
+		cursor = queueutils.select(order=[str(orderby)], where = where, limit = limit, offset = offset)
+	
+		totalcost = 0
+		totalmin = 0
+		
+		row = cursor.fetchone()
+		if row and int(offset) >= 0 and int(offset) <= total and cursor.description:
+		
+			'<table border="1"><thead><tr>'
+                	for s in cursor.description:
+				'<th>'
+				if s[0] == field:
+					neworder = (order=='ASC' and 'DESC') or 'ASC'
+					"<a href='javascript:orderby(\"%s\",\"%s\")'>%s</a>" % (s[0], neworder, M_(s[0]))
+					if order=='ASC':
+						" <img src='/static/down.gif' border='0' alt='%s' />\n" % M_('Asc. Order')
+					else:
+						" <img src='/static/up.gif' border='0' alt='%s' />\n" % M_('Desc. Order')
+				else:
+					"<a href='javascript:orderby(\"%s\",\"%s\")'>%s</a>" % (s[0], order, M_(s[0]))
+				'</th>'
+                	'</tr></thead><tbody>'
+		
+			if cursor.description:
+				fieldIndices = range(len(cursor.description))
+			else:
+				fieldIndices = []
+                	while row:
+	                	'<tr>'
+				for fieldIndex in fieldIndices:
+					'<td><center>'
+					if row[fieldIndex] == "1969-12-31 19:00:00":
+						'-'
+#					elif cursor.description[fieldIndex][0] == "info2":
+#						s = int(row[fieldIndex])
+#						min = (s % 60) and ((s / 60) + 1) or (s / 60)
+#                                               	totalmin += min
+#						min
+					else: 
+						row[fieldIndex]
+        	                       	'</center></td>'
+				'</tr>'
+				row = cursor.fetchone()
+                	'</tbody></table><br/>'
+			'<p>'
+
+			f = offset + limit
+			if total >= f:			
+				M_('Showing records from %s to %s of %s' % (offset+1, f, total))
+			else:
+				M_('Showing records from %s to %s of %s') % (offset+1, total, total)
+			'<br /><br />'
+
+	#	M_('Total Duration of shown calls: %s min.') % totalmin
+		'</p>'
+
+
+class Page(AccessControlled, Directory): 
+
+	_q_parent = 'page_stats'
+	_q_title  = _("Agent Details")
+	_q_desc   = _("Get statistics about queue received calls by Agent")
+	_q_level  = 2
+	_q_menupos = 20
+
+	_q_exports = ['']
+
+	def _q_access(self):
+		self.session = get_session()
+		self.request = get_request()
+		if self.session.level < self._q_level:
+			cantAccessPage()
+
+	def _q_test(self):
+		return queueutils.db
+
+	def _q_index [plain] (self):
+		header(self._q_desc, scripts=[formScript])
+		cdrForm(self.request)
+		footer()

Modified: trunk/page_stats_calls.ptl
===================================================================
--- trunk/page_stats_calls.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats_calls.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -232,7 +232,7 @@
 	_q_parent = 'page_stats'
 	_q_title  = _("Calls Statistics")
 	_q_desc   = _("Calls Statistics")
-	_q_level  = 3
+	_q_level  = 2
 	_q_menupos = 30
 
 	_q_exports = ['']

Modified: trunk/page_stats_cdr.ptl
===================================================================
--- trunk/page_stats_cdr.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats_cdr.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -58,7 +58,11 @@
 
 def pageIndex [html] (pagenum, total, limit):
 	"<p>"
+	if limit == 0:
+		limit=1
+
 	lastpage = total/limit
+
 	if pagenum > 1:
 		"<a href='javascript:gotopage(\"_newest\")'>%s</a> &nbsp; \n" % M_("First")
 		"<a href='javascript:gotopage(\"_newer\")'>%s</a> &nbsp; \n" % M_("Previous")
@@ -297,7 +301,7 @@
 	_q_parent = 'page_stats'
 	_q_title  = _("Call Details")
 	_q_desc   = _("Get statistics about made and received calls")
-	_q_level  = 3
+	_q_level  = 2
 	_q_menupos = 20
 
 	_q_exports = ['']

Modified: trunk/page_stats_dialouts.ptl
===================================================================
--- trunk/page_stats_dialouts.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats_dialouts.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -171,7 +171,7 @@
 	_q_parent = 'page_stats'
 	_q_title  = _("Dialout Statistics")
 	_q_desc   = _("Statistics for Dialout Entries")
-	_q_level  = 3
+	_q_level  = 2
 	_q_menupos = 32
 
 	_q_exports = ['']

Modified: trunk/page_stats_phone.ptl
===================================================================
--- trunk/page_stats_phone.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats_phone.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -178,7 +178,7 @@
 	_q_parent = 'page_stats'
 	_q_title  = _("Extension Statistics")
 	_q_desc   = _("Statistics for an Extension")
-	_q_level  = 3
+	_q_level  = 2
 	_q_menupos = 32
 
 	_q_exports = ['']

Modified: trunk/page_stats_queue.ptl
===================================================================
--- trunk/page_stats_queue.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats_queue.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -37,7 +37,7 @@
 	_q_parent = 'page_stats'
 	_q_title  = _("Queue Statistics")
 	_q_desc   = _("Incoming Call Statistics by Queue")
-	_q_level  = 3
+	_q_level  = 2
 	_q_menupos = 30
 
 	_q_exports = ['']
@@ -110,7 +110,7 @@
 	where = []
 	where.append("date(timestamp) = date('%s')" % date)
 	where.append("qname = '%s'" % queue)
-	where_completed = where + [("action like 'COMPLETE%'")]
+	where_completed = where + [("(action like 'COMPLETE%' or action like 'TRANSFER')")]
 	cursor = queueutils.select(
 				fields = ['time(timestamp) as hour', 'agent', 'action', 'info1', 'info2', 'info3'],
 				where = where_completed,
@@ -153,7 +153,7 @@
 	where = []
 	where.append("date(timestamp) between date('%s') and date('%s')" % (date1, date2))
 	where.append("qname = '%s'" % queue)
-	where_completed = where + [("action like 'COMPLETE%'")]
+	where_completed = where + [("(action like 'COMPLETE%' or action like 'TRANSFER')")]
 	cursor = queueutils.select(
 				fields = ['date(timestamp) as day', 'agent', 'action', 'info1', 'info2', 'info3'],
 				where = where_completed,
@@ -196,7 +196,7 @@
 	where = []
 	where.append("date(timestamp) between date('%s') and date('%s')" % (date1, date2))
 	where.append("qname = '%s'" % queue)
-	where_completed = where + [("action like 'COMPLETE%'")]
+	where_completed = where + [("(action like 'COMPLETE%' or action like 'TRANSFER')")]
 	cursor = queueutils.select(
 				fields = ['date(timestamp) as month', 'agent', 'action', 'info1', 'info2', 'info3'],
 				where = where_completed,
@@ -236,7 +236,7 @@
 def perYear [plain] (queue):
 	where = []
 	where.append("qname = '%s'" % queue)
-	where_completed = where + [("action like 'COMPLETE%'")]
+	where_completed = where + [("(action like 'COMPLETE%' or action like 'TRANSFER')")]
 	cursor = queueutils.select(
 				fields = ['date(timestamp) as year', 'agent', 'action', 'info1', 'info2', 'info3'],
 				where = where_completed,
@@ -280,9 +280,14 @@
 	agentnames = []
 	total_completed_by_agent = 0
 	total_completed_by_caller = 0
+	total_transfered = 0
 	total_duration = 0
 	total_holdtime = 0
-	holdtimes = ['< 15','< 30','< 45','< 60','< 75','< 90','>= 90']
+	holdtimes = []
+	for h in range(5,95,5):
+		holdtimes.append('< %s' % h)
+	holdtimes.append('>= 90')
+
 	calls_per_holdtime = [CallData() for i in holdtimes]
 
 	if cursor.description:
@@ -317,6 +322,8 @@
 					total_completed_by_agent += 1
 				if disposition == "COMPLETECALLER":
 					total_completed_by_caller += 1
+				if disposition == "TRANSFER":
+					total_transfered += 1
 			if c=='info1':
 				try:
 					holdtime = int(s)
@@ -327,11 +334,26 @@
 					calltime = int(s)
 				except ValueError:
 					calltime = 0
-			if c=='info2':
-				try:
-					origposition = int(s)
-				except ValueError:
-					origposition = 0
+			if c=='info3':
+				if disposition != "TRANSFER":
+					try:
+						origposition = int(s)
+					except ValueError:
+						origposition = 0
+				else:
+					try:
+						holdtime = int(s)
+					except ValueError:
+						holdtime = 0
+#			if c=='info4':
+#				if disposition == "TRANSFER":
+#					try:
+#						calltime = int(s)
+#					except ValueError:
+#						calltime = 0
+
+
+
 		total_duration += calltime
 		total_holdtime += holdtime
 		calls_per_period [period].addQueueCall(holdtime, calltime, disposition)
@@ -342,8 +364,8 @@
 		calls_by_agent[agentnames.index(agent)].addQueueCall(holdtime, calltime, "")
 		row = cursor.fetchone()
 
-	completed_table = makeCompletedTable(total_completed_by_agent, total_completed_by_caller, total_duration, total_holdtime)
-	service_table = makeServiceTable((total_completed_by_agent + total_completed_by_caller), calls_per_holdtime, holdtimes)
+	completed_table = makeCompletedTable(total_completed_by_agent, total_completed_by_caller, total_duration, total_holdtime, total_transfered)
+	service_table = makeServiceTable((total_completed_by_agent + total_completed_by_caller + total_transfered), calls_per_holdtime, holdtimes)
 
 	return [calls_per_period, calls_by_agent, agentnames, completed_table, service_table]
 	
@@ -406,8 +428,8 @@
 
 	return [calls_per_period, calls_by_agent, agentnames, table]
 
-def makeCompletedTable [plain] (total_completed_by_agent, total_completed_by_caller, total_duration, total_holdtime):
-	total_completed = total_completed_by_agent + total_completed_by_caller
+def makeCompletedTable [plain] (total_completed_by_agent, total_completed_by_caller, total_duration, total_holdtime, total_transfered):
+	total_completed = total_completed_by_agent + total_completed_by_caller + total_transfered
 	table = HtmlTable(1,1)
 	table.setCell(0,0, _("Total completed calls"))
 	table.setCell(1,0, "%d" % total_completed)
@@ -415,12 +437,14 @@
 	table.setCell(1,1, "%d" % total_completed_by_agent)
 	table.setCell(0,2, _("Calls terminated by caller"))
 	table.setCell(1,2, "%d" % total_completed_by_caller)
-	table.setCell(0,3, _("Total call duration"))
-	table.setCell(1,3, "%d" % total_duration)
-	table.setCell(0,4, _("Average call duration"))
-	table.setCell(1,4, "%d" % (total_completed and (total_duration / total_completed) or 0))
-	table.setCell(0,5, _("Average hold time"))
-	table.setCell(1,5, "%d" % (total_completed and (total_holdtime / total_completed) or 0))
+	table.setCell(0,3, _("Calls transfered by agent"))
+	table.setCell(1,3, "%d" % total_transfered)
+	table.setCell(0,4, _("Total call duration"))
+	table.setCell(1,4, "%d" % total_duration)
+	table.setCell(0,5, _("Average call duration"))
+	table.setCell(1,5, "%d" % (total_completed and (total_duration / total_completed) or 0))
+	table.setCell(0,6, _("Average hold time"))
+	table.setCell(1,6, "%d" % (total_completed and (total_holdtime / total_completed) or 0))
 	return table
 	
 def makeUncompletedTable [plain] (

Modified: trunk/page_stats_trunks.ptl
===================================================================
--- trunk/page_stats_trunks.ptl	2009-11-18 22:17:30 UTC (rev 836)
+++ trunk/page_stats_trunks.ptl	2009-12-14 22:25:56 UTC (rev 837)
@@ -184,7 +184,7 @@
 	_q_parent = 'page_stats'
 	_q_title  = _("Trunk Statistics")
 	_q_desc   = _("Statistics for Trunks")
-	_q_level  = 3
+	_q_level  = 2
 	_q_menupos = 32
 
 	_q_exports = ['']



From alerios at mail.berlios.de  Tue Dec 15 02:53:54 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 02:53:54 +0100
Subject: [Destar-dev] r838 - trunk
Message-ID: <200912150153.nBF1rso0017507@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 02:53:54 +0100 (Tue, 15 Dec 2009)
New Revision: 838

Modified:
   trunk/CHANGELOG.txt
   trunk/page_user_dial.ptl
Log:
* Fixed missing argument to originateCallExt in page_user_dial.pt


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-14 22:25:56 UTC (rev 837)
+++ trunk/CHANGELOG.txt	2009-12-15 01:53:54 UTC (rev 838)
@@ -2,6 +2,7 @@
 * page_stats_*.ptl: set _q_level = 2
 * Added page_stats_agents.ptl
 * Added TRANSFER query on page_stats_queue.ptl
+* Fixed missing argument to originateCallExt in page_user_dial.ptl
 
 2009-04-16
 * Zap -> DAHDI changes from branch icom-avatar

Modified: trunk/page_user_dial.ptl
===================================================================
--- trunk/page_user_dial.ptl	2009-12-14 22:25:56 UTC (rev 837)
+++ trunk/page_user_dial.ptl	2009-12-15 01:53:54 UTC (rev 838)
@@ -46,8 +46,8 @@
 		if component:
 			if self.session.phone:
 				phone = backend.getConfiglet(name=self.session.phone)
-				manager.originateCallExt("%s/%s" % (phone.technology, phone.name), "out-%s" % phone.name, component, "1")
-				return redirect("../")
+				manager.originateCallExt("%s/%s" % (phone.technology, phone.name), "out-%s" % phone.name, component, "1", phone.ext)
+				return redirect("../phoneslist")
 			else:
 				return errorpage(_("You don't have an associated phone"))
 		else:



From alerios at mail.berlios.de  Tue Dec 15 02:58:31 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 02:58:31 +0100
Subject: [Destar-dev] r839 - trunk
Message-ID: <200912150158.nBF1wVj6017742@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 02:58:31 +0100 (Tue, 15 Dec 2009)
New Revision: 839

Modified:
   trunk/CHANGELOG.txt
   trunk/page_user_phonebook.ptl
Log:
* Added manager verification on page_user_phonebook.ptl


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-15 01:53:54 UTC (rev 838)
+++ trunk/CHANGELOG.txt	2009-12-15 01:58:31 UTC (rev 839)
@@ -3,6 +3,7 @@
 * Added page_stats_agents.ptl
 * Added TRANSFER query on page_stats_queue.ptl
 * Fixed missing argument to originateCallExt in page_user_dial.ptl
+* Added manager verification on page_user_phonebook.ptl
 
 2009-04-16
 * Zap -> DAHDI changes from branch icom-avatar

Modified: trunk/page_user_phonebook.ptl
===================================================================
--- trunk/page_user_phonebook.ptl	2009-12-15 01:53:54 UTC (rev 838)
+++ trunk/page_user_phonebook.ptl	2009-12-15 01:58:31 UTC (rev 839)
@@ -45,6 +45,16 @@
 
 	def _q_index [plain] (self):
 		header(self._q_desc)
+		manager.connect()
+		if not manager.isConnected():
+			'<p><span class="errornotice">'
+			htmltext(_("Asterisk is not running!"))
+			'</span></p>'
+		elif not manager.isLoggedIn():
+			# TODO: describe how to set this up
+			'<p><span class="errornotice">'
+			htmltext(_("The manager access is not working!"))
+			'</span></p>'
         
 		'<h3>Phones</h3>'
 		'<table>'



From alerios at mail.berlios.de  Tue Dec 15 03:09:25 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 03:09:25 +0100
Subject: [Destar-dev] r840 - trunk
Message-ID: <200912150209.nBF29PEC018127@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 03:09:25 +0100 (Tue, 15 Dec 2009)
New Revision: 840

Added:
   trunk/cfg_phone_rxfax.py
Modified:
   trunk/CHANGELOG.txt
Log:
* Added cfg_phone_rxfax to use ReceiveFax asterisk 1.6 app.


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-15 01:58:31 UTC (rev 839)
+++ trunk/CHANGELOG.txt	2009-12-15 02:09:25 UTC (rev 840)
@@ -4,6 +4,7 @@
 * Added TRANSFER query on page_stats_queue.ptl
 * Fixed missing argument to originateCallExt in page_user_dial.ptl
 * Added manager verification on page_user_phonebook.ptl
+* Added cfg_phone_rxfax to use ReceiveFax asterisk 1.6 app.
 
 2009-04-16
 * Zap -> DAHDI changes from branch icom-avatar

Added: trunk/cfg_phone_rxfax.py
===================================================================
--- trunk/cfg_phone_rxfax.py	2009-12-15 01:58:31 UTC (rev 839)
+++ trunk/cfg_phone_rxfax.py	2009-12-15 02:09:25 UTC (rev 840)
@@ -0,0 +1,83 @@
+# -*- coding: utf-8 -*-
+#
+# Destar has Copyright (C) 2005 by Holger Schurig,
+# This file has Copyright (C) 2009 by Alejandro Rios.
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+from configlets import *
+
+
+class CfgPhoneRxfax(CfgPhone):
+
+	shortName = _("RxFax extension")
+	newObjectTitle = _("New RxFax extensiom")
+	description = _("This is an extension to receive faxes through the ReceiveFax asterisk 1.6 application.")
+	groupName = "Fax"
+	
+	def createVariables(self):
+		self.variables = [
+			VarType("pbx",    
+				title=_("Virtual PBX"), 
+				type="choice", 
+				options=getChoice("CfgOptPBX")),
+
+			VarType("name",
+				title=_("Name"),
+				len=15),
+
+			VarType("ext",
+				title=_("Extension"),
+				len=13),
+				
+			VarType("filename",
+					title=_("Fax .tiff file name"),
+					hint=_("Otherwise it will use UniqueID"),
+					len=25,
+					optional=True)]
+					
+		self.dependencies = [
+			DepType("pbx", 
+					type="hard",
+					message = _("This is a Dependency")),]
+
+	def isAddable(self):
+		"We can only add this object if we have at least one pbx defined."
+
+		# BUG: it does somehow not work to simply write for obj in config_entries,
+		# despite the "from configlets import *" above
+		import configlets
+		if len(configlets.configlet_tree.getConfigletsByName('CfgOptPBX')) > 0:
+			return True
+		return False
+	isAddable = classmethod(isAddable)
+
+	def createAsteriskConfig(self):
+		needModule("app_fax")
+		needModule("app_system")
+		fax = AstConf("extensions.conf")
+		fax.setSection(self.pbx)
+		if self.filename:
+			dest_file = "/var/spool/asterisk/fax_%s" % self.filename
+		else:
+			dest_file = "/var/spool/asterisk/fax_${UNIQUEID}"
+		fax.appendExten("_%s" % self.ext,"Goto(fax,${EXTEN},1)")
+		fax.setSection("fax")
+		fax.append("exten=>_%s,1,Set(FAXFILE=%s)" % (self.ext,dest_file))
+		fax.append("exten=>_%s,n,ReceiveFAX(${FAXFILE}.tif)" %  (self.ext))
+		fax.append("exten=>_%s,n,Wait(2)" %  (self.ext))
+		fax.append('''exten=>_%s,n,System(fax2mail --cid-number "${CALLERID(num)}" --cid-name "${CALLERID(name)}" -f "${FAXFILE}"''' %  (self.ext) )
+		fax.append("exten=>_%s,n,Hangup()" %  (self.ext))


Property changes on: trunk/cfg_phone_rxfax.py
___________________________________________________________________
Name: svn:executable
   + *



From alerios at mail.berlios.de  Tue Dec 15 03:29:37 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 03:29:37 +0100
Subject: [Destar-dev] r841 - trunk
Message-ID: <200912150229.nBF2Tbef018956@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 03:29:37 +0100 (Tue, 15 Dec 2009)
New Revision: 841

Modified:
   trunk/CHANGELOG.txt
   trunk/backend.py
Log:
* backend.py:
  - Add Call Forwarding loop detection
  - Added macro-send-fax
  - Added macro-call-forward-warning


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-15 02:09:25 UTC (rev 840)
+++ trunk/CHANGELOG.txt	2009-12-15 02:29:37 UTC (rev 841)
@@ -5,6 +5,10 @@
 * Fixed missing argument to originateCallExt in page_user_dial.ptl
 * Added manager verification on page_user_phonebook.ptl
 * Added cfg_phone_rxfax to use ReceiveFax asterisk 1.6 app.
+* backend.py:
+  - Add Call Forwarding loop detection
+  - Added macro-send-fax
+  - Added macro-call-forward-warning
 
 2009-04-16
 * Zap -> DAHDI changes from branch icom-avatar

Modified: trunk/backend.py
===================================================================
--- trunk/backend.py	2009-12-15 02:09:25 UTC (rev 840)
+++ trunk/backend.py	2009-12-15 02:29:37 UTC (rev 841)
@@ -195,8 +195,11 @@
 	c.append(";")
 	c.setSection("macro-dial-std-exten")
 	c.append(";")
+	c.append("; test for CF count")
+	c.append('exten=s,1,GotoIf($[${cf_count} >= 2]?nocf:cfim)')
+	c.append("exten=s,n(nocf),Goto(hangup)")
 	c.append("; test for CFIM (Call Forwarding Immediate)")
-	c.append("exten=s,1,Set(fw_ext=${DB(CFIM/${ARG4}/${ARG3})})")
+	c.append("exten=s,n(cfim),Set(fw_ext=${DB(CFIM/${ARG4}/${ARG3})})")
 	c.append('exten=s,n,GotoIf($["${fw_ext}" != ""]?fw)')
 	c.append(";")
 	c.append("; test for VMIM (VM Immediate)")
@@ -210,7 +213,7 @@
 	c.append("; get dial seconds")
 	c.append("exten=s,n,Set(dsec=${DB(DSEC/${ARG4}/${ARG3})})")
 	c.append('exten=s,n,GotoIf($["${dsec}" != ""]?dsecEnd)')
-	c.append("exten=s,n,Set(dsec=45)")
+	c.append("exten=s,n,Set(dsec=25)")
 	c.append("exten=s,n(dsecEnd),NoOp()")
 	c.append(";")
 	c.append("; get global dial options")
@@ -265,7 +268,9 @@
 	c.append("exten=s,n,PlayTones(busy)")
 	c.append("exten=s,n,Busy()")
 	c.append(";")
-	c.append("exten=s,n(fw),Goto(${ARG2},${fw_ext},1)")
+	c.append("exten=s,n(fw),Set(cf_count=$[${cf_count} + 1])")
+	c.append("exten=s,n,Set(CALLERID(num)=${CALLERID(num)}-${ARG3})")
+	c.append("exten=s,n,Goto(real-${ARG2},${fw_ext},1)")
 	c.append(";")
 	c.append('exten=s,n(vmu),Set(vmopt=u)')
 	c.append("exten=s,n,Macro(voicemail,${vmopt}${ARG3},${ARG4})")
@@ -298,20 +303,45 @@
 	c.append("exten => s,5,Hangup()")
 
 	c.append(";")
+	c.append("; format: Macro(sendfax,filename,waittime)")
+	c.append(";")
+	needModule("app_fax")
+	context="macro-sendfax"
+	c.setSection(context)
+	c.appendExten("s", "Answer()", context)
+	c.appendExten("s", "Wait(${ARG2})", context)
+        c.appendExten("s", "Set(LOCALSTATIONID=%s)" getSetting('header_text', 'DeStar PBX'), context)
+        c.appendExten("s", "SendFAX(${FAXFILE})", context)
+	c.appendExten("s", "Hangup", context)
+        c.appendExten("h", "NoOp(TX: REMOTESTATIONID is ${REMOTESTATIONID})", context)
+	c.appendExten("h", "UserEvent(FAX|SEND: Call ended normally)", context)
+
+	c.append(";")
 	c.append("; format: Macro(call-forward,type,pbx,destination,message-to-play)")
 	c.append(";")
-	c.setSection("macro-call-forward")
-	c.appendExten("s", "Answer()")
-	c.appendExten("s", "Set(DB(${ARG1}/${ARG2}/${CALLERIDNUM})=${ARG3})")
-	c.appendExten("s", "Set(DB(${ARG1}_LASTNUM/${ARG2}/${CALLERIDNUM})=${ARG3})")
-	c.appendExten("s", "Playback(${ARG4})")
-	c.appendExten("s", "Playback(has-been-set-to)")
-	c.appendExten("s", "SayDigits(${ARG3})")
-	c.appendExten("s", "Wait(1)")
-	c.appendExten("s", "Playback(vm-goodbye)")
-	c.appendExten("s", "Hangup")
+	context="macro-call-forward"
+	c.setSection(context)
+	c.appendExten("s", "Answer()", context)
+	c.appendExten("s", "Set(DB(${ARG1}/${ARG2}/${CALLERIDNUM})=${ARG3})", context)
+	c.appendExten("s", "Set(DB(${ARG1}_LASTNUM/${ARG2}/${CALLERIDNUM})=${ARG3})", context)
+	c.appendExten("s", "Playback(${ARG4})", context)
+	c.appendExten("s", "Playback(has-been-set-to)", context)
+	c.appendExten("s", "SayDigits(${ARG3})", context)
+	c.appendExten("s", "Wait(1)", context)
+	c.appendExten("s", "Playback(vm-goodbye)", context)
+	c.appendExten("s", "Hangup", context)
 
 	c.append(";")
+	c.append("; format: Macro(call-forward-warning,destination,message-to-play)")
+	c.append(";")
+	context="macro-call-forward-warning"
+	c.setSection(context)
+	c.appendExten("s", "Answer()", context)
+	c.appendExten("s", "Playback(${ARG2})", context)
+	c.appendExten("s", "Playback(has-been-set-to)", context)
+	c.appendExten("s", "SayDigits(${ARG1})", context)
+
+	c.append(";")
 	c.append("; format: Macro(record,filename,format,maxduration)")
 	c.append(";")
 	c.setSection("macro-record")



From alerios at mail.berlios.de  Tue Dec 15 03:37:54 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 03:37:54 +0100
Subject: [Destar-dev] r842 - in trunk: . lang/es/LC_MESSAGES
	lang/fr/LC_MESSAGES
Message-ID: <200912150237.nBF2bsGQ019273@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 03:37:54 +0100 (Tue, 15 Dec 2009)
New Revision: 842

Removed:
   trunk/lang/es/LC_MESSAGES/destar.mo
   trunk/lang/fr/LC_MESSAGES/destar.mo
Modified:
   trunk/.svnignore
Log:
Don't upload .mo gettext to repository.


Modified: trunk/.svnignore
===================================================================
--- trunk/.svnignore	2009-12-15 02:29:37 UTC (rev 841)
+++ trunk/.svnignore	2009-12-15 02:37:54 UTC (rev 842)
@@ -1,3 +1,4 @@
 *.ptlc
 *.pyc
+*.mo
 a

Deleted: trunk/lang/es/LC_MESSAGES/destar.mo
===================================================================
(Binary files differ)

Deleted: trunk/lang/fr/LC_MESSAGES/destar.mo
===================================================================
(Binary files differ)



From alerios at mail.berlios.de  Tue Dec 15 03:45:05 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 03:45:05 +0100
Subject: [Destar-dev] r843 - trunk
Message-ID: <200912150245.nBF2j5Ko019542@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 03:45:04 +0100 (Tue, 15 Dec 2009)
New Revision: 843

Modified:
   trunk/CHANGELOG.txt
   trunk/cfg_ivr_treenode.py
Log:
* cfg_ivr_treenode.py:
  - Added extension to test IVR from the inside.
  - Admin may change incoming callerID.
  - Choose if jump to operator or head of IVR by default.



Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-15 02:37:54 UTC (rev 842)
+++ trunk/CHANGELOG.txt	2009-12-15 02:45:04 UTC (rev 843)
@@ -9,6 +9,10 @@
   - Add Call Forwarding loop detection
   - Added macro-send-fax
   - Added macro-call-forward-warning
+* cfg_ivr_treenode.py: 
+  - Added extension to test IVR from the inside.
+  - Admin may change incoming callerID.
+  - Choose if jump to operator or head of IVR by default.
 
 2009-04-16
 * Zap -> DAHDI changes from branch icom-avatar

Modified: trunk/cfg_ivr_treenode.py
===================================================================
--- trunk/cfg_ivr_treenode.py	2009-12-15 02:37:54 UTC (rev 842)
+++ trunk/cfg_ivr_treenode.py	2009-12-15 02:45:04 UTC (rev 843)
@@ -35,6 +35,15 @@
 					title=_("Name"),
 					len=25),
 
+			VarType("ext",
+					title=_("Extension to test"),
+					len=6),
+
+                        VarType("clid",
+                                        title = _("Change Caller ID name to:"),
+                                        len = 35,
+                                        optional = True),
+
 			VarType("digittimeout",
 					title=_("How much time has the user to dial an extension?"),
 					hint=_("(in seconds)"),
@@ -73,6 +82,7 @@
 			VarType("operator",
 					title=_("Extension to ring after file playing or by pressing '0'"),
 					type="choice",
+					optional=True,
 					options=getChoice("CfgPhone")),
 
 			VarType("waittime",
@@ -256,12 +266,19 @@
 	def createAsteriskConfig(self):
 		s = AstConf("extensions.conf")
 		context = self.name
-		s.setSection(context)
 		if self.pbx:
 			pbx = self.pbx
 		else:	
 			pbx = "phones"
+		if self.ext:
+			s.setSection(pbx)
+			s.appendExten(self.ext,"Goto(%s,s,1)" % self.name, context=pbx)	
+		s.setSection(context)
 		s.append("include=%s" % pbx)
+		if self.clid:
+                                needModule("func_callerid")
+                                s.appendExten("s","Set(CALLERID(name)=%s)" %  self.clid, context)
+	
 		s.appendExten("s","Set(TIMEOUT(digit)=%d)" % self.digittimeout, context)
 		if self.moh:
 			s.appendExten("s","Setmusiconhold(%s)" % self.moh, context)
@@ -280,7 +297,10 @@
 			if self.pause:
 				s.appendExten("s","WaitExten(%s)" % self.pause, context)
 		s.appendExten("s","WaitExten(%d)" % self.waittime, context)
-		s.appendExten("s","Goto(%s,%s,1)" % (pbx,self.operator), context)	
+		if self.operator:
+			s.appendExten("s","Goto(%s,%s,1)" % (pbx,self.operator), context)	
+		else:
+			s.appendExten("s","Goto(s,1)", context)	
 		if self.ivr_1:
 			s.appendExten("1","Goto(%s,s,1)" % self.ivr_1, context)	
 		if self.ivr_2:
@@ -323,7 +343,8 @@
 			s.appendExten("*","Goto(%s,%s,1)" % (pbx,self.phone_ast), context)	
 		s.appendExten("0", "Goto(%s,%s,1)" % (pbx,self.operator), context)	
 		s.appendExten("i","Playback(invalid)", context)	
-		s.appendExten("i","Goto(%s,%s,1)" % (pbx,self.operator), context)	
+		#s.appendExten("i","Goto(%s,%s,1)" % (pbx,self.operator), context)	
+		s.appendExten("i","Goto(s,1)", context)	
 		s.appendExten("t","ResetCDR(w)", context)
 		s.appendExten("t","NoCDR", context)
 		s.appendExten("t","Hangup", context)



From alerios at mail.berlios.de  Tue Dec 15 04:02:12 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 04:02:12 +0100
Subject: [Destar-dev] r844 - trunk
Message-ID: <200912150302.nBF32Cpl020213@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 04:02:12 +0100 (Tue, 15 Dec 2009)
New Revision: 844

Modified:
   trunk/CHANGELOG.txt
   trunk/cfg_app_disa.py
Log:
* Added AtributeException catch on cfg_app_disa.py


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-15 02:45:04 UTC (rev 843)
+++ trunk/CHANGELOG.txt	2009-12-15 03:02:12 UTC (rev 844)
@@ -13,6 +13,7 @@
   - Added extension to test IVR from the inside.
   - Admin may change incoming callerID.
   - Choose if jump to operator or head of IVR by default.
+* Added AtributeException catch on cfg_app_disa.py
 
 2009-04-16
 * Zap -> DAHDI changes from branch icom-avatar

Modified: trunk/cfg_app_disa.py
===================================================================
--- trunk/cfg_app_disa.py	2009-12-15 02:45:04 UTC (rev 843)
+++ trunk/cfg_app_disa.py	2009-12-15 03:02:12 UTC (rev 844)
@@ -46,23 +46,26 @@
 				len=6,
 				default="*171"),
 
-			VarType("Dialout",
-				title=_("Allowed dialout-entries"),
-				type="label",
-				hide=True),
+			VarType("phone",
+					title=_("Log into phone"),
+					type="choice",
+					options=getChoice("CfgPhone"))
+				]
+	def isAddable(self):
+		"We can only add this object if we have at least one other phone defined."
 
-			VarType("timeout",
-				title=_("Enable time restriction?"),
-				type="bool",
-				optional=True,
-				hide=True),]
-		if varlist_manager.hasDialouts():
-                        self.variables += varlist_manager.getDialouts()
-                        for v in self.variables:
-                                if v.name == "Dialout" or v.name=="timeout":
-                                        v.hide = False
+		# BUG: it does somehow not work to simply write for obj in config_entries,
+		# despite the "from configlets import *" above
+		import configlets
+		if len(configlets.configlet_tree.getConfigletsByName('CfgOptPBX')) > 0:
+			for obj in configlets.configlet_tree:
+				if obj.groupName == 'Phones':
+					return True
+		return False
+	isAddable = classmethod(isAddable)
+
+
 	
-	
 	def row(self):
 		return ("%s" % (self.ext),self.shortName)
 
@@ -81,7 +84,20 @@
 		c = AstConf("extensions.conf")
 		c.setSection("%s" % self.pbx)
 		needModule("app_disa")	
-		c.appendExten("%s" % self.ext ,"Set(TIMEOUT(digit)=5)", self.pbx)
-		c.appendExten("%s" % self.ext ,"Set(TIMEOUT(response)=10)", self.pbx)
-		c.appendExten("%s" % self.ext ,"Authenticate(%s)" % self.pin, self.pbx)
-		c.appendExten("%s" % self.ext ,"DISA(no-password,out-%s)" % self.name, self.pbx)
+		import configlets
+		obj = configlets.configlet_tree.getConfigletByName(self.phone)
+                try:
+                        if obj.calleridname:
+                                cidname=obj.calleridname
+                        else:
+                                cidname=obj.name
+                        if obj.calleridnum:
+                                cidnum=obj.calleridnum
+                        else:
+                                cidnum=obj.ext
+                        c.appendExten("%s" % self.ext ,"Set(TIMEOUT(digit)=5)", self.pbx)
+                        c.appendExten("%s" % self.ext ,"Set(TIMEOUT(response)=10)", self.pbx)
+                        c.appendExten("%s" % self.ext ,"Authenticate(%s)" % self.pin, self.pbx)
+                        c.appendExten("%s" % self.ext ,'DISA(no-password,real-out-%s,"%s" <%s>' % (obj.name, cidname, cidnum), self.pbx)
+                except AttributeError:
+                        pass



From alerios at mail.berlios.de  Tue Dec 15 23:50:05 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Tue, 15 Dec 2009 23:50:05 +0100
Subject: [Destar-dev] r845 - in trunk: . static/themes/avatar
	static/themes/avatar/css static/themes/avatar/imgs
Message-ID: <200912152250.nBFMo5Zc012553@sheep.berlios.de>

Author: alerios
Date: 2009-12-15 23:50:03 +0100 (Tue, 15 Dec 2009)
New Revision: 845

Added:
   trunk/static/themes/avatar/css/
   trunk/static/themes/avatar/css/ADxMenu.htc
   trunk/static/themes/avatar/css/Menu.css
   trunk/static/themes/avatar/css/Menu4IE.css
   trunk/static/themes/avatar/css/general.css
   trunk/static/themes/avatar/imgs/
   trunk/static/themes/avatar/imgs/_notes/
   trunk/static/themes/avatar/imgs/body-f.jpg
   trunk/static/themes/avatar/imgs/btn-aceptar.gif
   trunk/static/themes/avatar/imgs/btn-cancelar.gif
   trunk/static/themes/avatar/imgs/btn-enviar.gif
   trunk/static/themes/avatar/imgs/content-f.jpg
   trunk/static/themes/avatar/imgs/contentnav-f.jpg
   trunk/static/themes/avatar/imgs/footer-f.jpg
   trunk/static/themes/avatar/imgs/header-f.jpg
   trunk/static/themes/avatar/imgs/icom-logo.gif
   trunk/static/themes/avatar/imgs/menu-f1.gif
   trunk/static/themes/avatar/imgs/menu-f2.gif
   trunk/static/themes/avatar/imgs/submenu-f_bottom.gif
   trunk/static/themes/avatar/imgs/submenu-f_top.gif
   trunk/static/themes/avatar/imgs/text-btn_f1.gif
   trunk/static/themes/avatar/imgs/text-btn_f2.gif
Modified:
   trunk/CHANGELOG.txt
Log:
* Added avatar web style



Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-15 03:02:12 UTC (rev 844)
+++ trunk/CHANGELOG.txt	2009-12-15 22:50:03 UTC (rev 845)
@@ -1,3 +1,6 @@
+2009-12-15
+* Added avatar web style
+
 2009-12-14
 * page_stats_*.ptl: set _q_level = 2
 * Added page_stats_agents.ptl

Added: trunk/static/themes/avatar/css/ADxMenu.htc
===================================================================
--- trunk/static/themes/avatar/css/ADxMenu.htc	2009-12-15 03:02:12 UTC (rev 844)
+++ trunk/static/themes/avatar/css/ADxMenu.htc	2009-12-15 22:50:03 UTC (rev 845)
@@ -0,0 +1,139 @@
+<attach event="ondocumentready" handler="_ParseStylesheets" />
+<script language="JScript">
+/**
+ *	ADxMenu behavior - standard - v0.21
+ *	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ *	(c) 2004 - Aleksandar Vacic, www.aplus.co.yu
+ * Licensed under http://creativecommons.org/licenses/by/2.0/
+ *	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ * Based on PSEUDOS V1.20.040828
+ *	http://www.xs4all.nl/~peterned/csshover.html
+ *	(c) 2004 - Peter Nederlof
+ *	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+ */
+
+var _oCurrentSheet, _oDoc = window.document;
+var _aActivators = {
+	onhover:{on:'onmouseover', off:'onmouseout'}
+}
+
+//	keeps the menu IDs
+var _aMenuIDs = new Array();
+
+//	find menus on the page - look for class named "adxm"
+function _FindMenus() {
+	var aTmp = xGetElementsByClassName("adxm", element.document, "ul", function(oM) {
+		_Add(oM.id);
+	} );
+};
+
+//	add the menu to the array
+function _Add(sMenuID) {
+	if ( typeof(sMenuID) == "undefined") return;
+	_aMenuIDs[_aMenuIDs.length] = sMenuID.replace(/List/, "");
+};
+
+function _ParseStylesheets() {
+	_FindMenus();
+	var sheets = _oDoc.styleSheets, l = sheets.length;
+	for(var i=0; i<l; i++) 
+		_ParseStylesheet(sheets[i]);
+}
+
+function _ParseStylesheet(sheet) {
+	var l, rules, imports;
+	if(sheet.imports) {
+		imports = sheet.imports, l = imports.length;
+		for(var i=0; i<l; i++) 
+			_ParseStylesheet(sheet.imports[i]);
+	}
+
+	rules = (_oCurrentSheet = sheet).rules, l = rules.length;
+	for(var j=0; j<l; j++) _ParseCSSRule(rules[j]);
+}
+
+function _ParseCSSRule(rule) {
+	var select = rule.selectorText, style = rule.style.cssText;
+
+	//	if style text is empty, IE throws "invalid pointer" error	
+	if ( style.replace(/ /, "") == "" ) return;
+	
+	//	work only with #menu
+	var sMenuID, bFound = 0;
+	for (var t=0;t<_aMenuIDs.length;t++) {
+		if (select.indexOf(_aMenuIDs[t]) != -1) {
+			bFound = 1;
+			sMenuID = _aMenuIDs[t];
+			break;
+		}
+	}
+	if (!bFound) return;
+
+	if(!(/(^|\s)(([^a]([^ ]+)?)|(a([^#.][^ ]+)+)):(hover)/i).test(select)) return;
+	
+	var pseudo = select.replace(/[^:]+:([a-z-]+).*/i, 'on$1');
+	var newSelect = select.replace(/(\.([a-z0-9_-]+):[a-z]+)|(:[a-z]+)/gi, '.$2' + pseudo);
+	var className = (/\.([a-z0-9_-]+)/i).exec(newSelect)[1];
+	var affected = select.replace(/:hover.*$/, '');
+
+	//	remove the #menu part
+	eval('affected = affected.replace(/#' + sMenuID + '([ ]+)/i, "")');
+
+	var elements = _GetElementsBySelect(affected, sMenuID);
+
+	_oCurrentSheet.addRule(newSelect, style);
+	for(var i=0; i<elements.length; i++)
+		new _HoverElement(elements[i], className, _aActivators[pseudo]);
+}
+
+function _HoverElement(node, className, events) {
+	if(!node.hovers) node.hovers = {};
+	if(node.hovers[className]) return;
+	node.hovers[className] = true;
+	node.attachEvent(events.on,
+		function() { node.className += ' ' + className; });
+	node.attachEvent(events.off,
+		function() { node.className = 
+			node.className.replace(new RegExp('\\s+'+className, 'g'),''); });
+}
+
+function _GetElementsBySelect(rule, sMenuID) {
+	//	work only inside of the #menu div
+	var parts, nodes = [_oDoc.getElementById(sMenuID)];
+	parts = rule.split(' ');
+	for(var i=0; i<parts.length; i++) {
+		nodes = _GetSelectedNodes(parts[i], nodes);
+	}
+	return nodes;
+}
+
+function _GetSelectedNodes(select, elements) {
+	var result, node, nodes = [];
+	var classname = (/\.([a-z0-9_-]+)/i).exec(select);
+	var identify = (/\#([a-z0-9_-]+)/i).exec(select);
+	var tagName = (/^[a-z0-9]+/i).exec(select.toUpperCase()) || '*';
+	for(var i=0; i<elements.length; i++) {
+		result = elements[i].getElementsByTagName(tagName);
+		for(var j=0; j<result.length; j++) {
+			node = result[j];
+			if((identify && node.id != identify[1]) || (classname && !(new RegExp('\\b' +
+				classname[1] + '\\b').exec(node.className)))) continue;
+			nodes[nodes.length] = node;
+		}
+	}	return nodes;
+}
+
+function xGetElementsByClassName(clsName, parentEle, tagName, fn) {
+	var found = new Array();
+	var re = new RegExp('\\b'+clsName+'\\b', 'i');
+	var list = parentEle.getElementsByTagName(tagName);
+	for (var i = 0; i < list.length; ++i) {
+		if (list[i].className.search(re) != -1) {
+			found[found.length] = list[i];
+			if (fn) fn(list[i]);
+		}
+	}
+	return found;
+}
+
+</script>
\ No newline at end of file


Property changes on: trunk/static/themes/avatar/css/ADxMenu.htc
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/static/themes/avatar/css/Menu.css
===================================================================
--- trunk/static/themes/avatar/css/Menu.css	2009-12-15 03:02:12 UTC (rev 844)
+++ trunk/static/themes/avatar/css/Menu.css	2009-12-15 22:50:03 UTC (rev 845)
@@ -0,0 +1,181 @@
+/* 
+ *		Horizontal, top-2-bottom menu
+ *		Copyright Aleksandar Vacic, www.aplus.co.yu, some rights reserved http://creativecommons.org/licenses/by/2.0/
+ */
+
+/*		------	Basic style	------		*/
+	#menu
+	{
+		clear:both;
+		display:block;
+		width:750px;
+		height:25px;
+		margin:0 0 0 15px;
+	}
+		#menu ul
+		{
+			margin:0;
+			padding:0;
+			border:0;
+			list-style-type:none;
+		}
+			#menu li
+			{
+				margin:0;
+				padding:0;
+				border:0;
+				display:block;
+				float:left;
+				position:relative;
+			}
+		#menu a
+		{
+			display:block;
+		}
+		#menu li li
+		{
+			width:100%;
+		}
+		
+		/* fix the position for 2nd level submenus. first make sure no horizontal scrollbars are visible on initial page load... */
+			#menu li li ul
+			{
+				top:0;
+				left:0;
+			}
+			
+			/* ...and then place it where it should be when shown */
+				#menu li li:hover ul
+				{
+					left:100%;
+				}
+		/* initialy hide all sub menus */
+		#menu li ul
+		{
+			display:none;
+			position:absolute;
+			z-index:10;
+		}
+		/* display them on hover */
+			#menu li:hover>ul
+			{
+				display:block;
+			}		
+		/* this is needed if you want to style #menu div - force containment of floated LIs inside of main UL */
+		#menuList:after
+		{
+			content:".";
+			height:0;
+			display:block;
+			visibility:hidden;
+			overflow:hidden;
+			clear:both;
+		}
+		/* Clear-fix for IE5/Mac \*//*/
+		#menu a
+		{
+			float:left;
+		}
+		
+		#menuList
+		{
+			display:inline-block;
+		}
+		/*  */
+		
+		/*		------   Make-up	--------			*/
+		
+	#menu
+	{
+		font-size:11px;
+		color:#FFFFFF;
+		min-height:25px;/* 	Height mentioned above	 */
+	}		
+		#menu li
+		{
+		}
+			#menu li li
+			{
+				background:none;
+				width:129px;
+			}		
+				#menu li li:last-child
+				{
+					
+				}
+				#menu a
+				{
+					font-size:11px;
+					font-weight:bold;
+					text-decoration:none;
+					text-align:left;
+					padding:0 0 0 10px;
+					background:url("../imgs/menu-f1.gif") -20px -20px no-repeat;
+				}
+					#menu a span
+					{
+						color:#FFFFFF;
+						padding:4px 10px 2px 0px;
+						display:block;
+						background:url("../imgs/menu-f1.gif") -20px -20px no-repeat;
+					}
+						#menu span em
+						{
+							text-decoration:underline;
+							font-style:normal;
+						}
+					/*Para cazar un bug en el IE-Apple*/
+					#menu a span
+					{
+						float:none;
+					}
+					/*Fin de la cacer?a*/
+				#menu li:hover>a
+				{
+					background:url("../imgs/menu-f1.gif") left top no-repeat;
+				}
+					#menu li:hover>a span
+					{
+						color:#990000;
+						background:url("../imgs/menu-f2.gif") right top no-repeat;
+						display:block;
+					}
+			#menu a:hover span
+			{
+				color:#990000;
+			}		
+				#menu li li a
+				{
+					color:#333333;
+					text-decoration:none;
+					font-size:1em;
+					font-weight:normal;
+					text-align:left;
+					background:none;
+					padding:5px 10px 5px 10px;
+				}
+					#menu li li:hover>a,
+					#menu li li a:hover
+					{
+						color:#000000 !important;
+						text-decoration:underline;
+						background:none;
+					}
+				#menu li ul
+				{
+					background:url("../imgs/submenu-f_bottom.gif") bottom repeat-y;
+					width:150px;
+				}
+					#menu li li ul
+					{
+						
+					}		
+						#menu li li li:first-child
+						{
+							
+						}
+						
+						#menu li li.submenu>a:after
+						{
+							content:" ...";
+						}
\ No newline at end of file


Property changes on: trunk/static/themes/avatar/css/Menu.css
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/static/themes/avatar/css/Menu4IE.css
===================================================================
--- trunk/static/themes/avatar/css/Menu4IE.css	2009-12-15 03:02:12 UTC (rev 844)
+++ trunk/static/themes/avatar/css/Menu4IE.css	2009-12-15 22:50:03 UTC (rev 845)
@@ -0,0 +1,60 @@
+/* 
+ *		Horizontal, top-2-bottom menu ## Tweaks for IE5, IE6
+ *		Copyright Aleksandar Vacic, www.aplus.co.yu, some rights reserved http://creativecommons.org/licenses/by/2.0/
+ */
+
+/*		------	Basic style	------		*/
+
+/* Fix IE6's inability to expand clickable area */
+#menu li a
+{
+	position:relative;
+}
+
+/* IE can't handle display, so fail-over to visibility */
+#menu li ul
+{
+	display:block;
+	visibility:hidden;
+}
+
+/* simulate child selector for IE */
+#menu li:hover ul,
+#menu li:hover li:hover ul,
+#menu li:hover li:hover li:hover ul
+{
+	visibility:visible;
+}
+#menu li:hover li ul,
+#menu li:hover li:hover li ul,
+#menu li:hover li:hover li:hover li ul
+{
+	visibility:hidden;
+}
+
+#menuList
+{
+	height:26px;
+}
+
+/*		------   Make-up	--------			*/
+
+#menu a:hover
+{
+	color:#990000;
+	background:url("../imgs/menu-f1.gif") left top no-repeat;
+}
+	#menu a:hover span
+	{
+		color:#990000;
+		background:url("../imgs/menu-f2.gif") right top no-repeat;
+		display:block;
+	}
+#menu li li a:hover
+{
+	color:#000000;
+	text-decoration:underline;
+	background:none;
+}
+
+/* 	------	Behaviors --------		*/
\ No newline at end of file


Property changes on: trunk/static/themes/avatar/css/Menu4IE.css
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/static/themes/avatar/css/general.css
===================================================================
--- trunk/static/themes/avatar/css/general.css	2009-12-15 03:02:12 UTC (rev 844)
+++ trunk/static/themes/avatar/css/general.css	2009-12-15 22:50:03 UTC (rev 845)
@@ -0,0 +1,379 @@
+body
+{
+	font-family:Arial, Helvetica, sans-serif;
+	text-align:center;
+	margin:0;
+	padding:16px 0 20px 0;
+	background:url("../imgs/body-f.jpg") 0 0;
+}
+	/*common definitions*/
+	#wrapper,
+	#header,
+	#mainContent,
+	#contentNav,
+	#footer
+	{
+		width:790px;
+	}
+		#header,
+		#mainContent,
+		#contentNav,
+		#footer
+		{
+			float:left;
+			text-align:left;
+		}
+			#mainContent, #footer
+			{
+				background:#FFFFFF;
+			}
+	/*end common definitions*/
+	#wrapper
+	{
+		margin-left:auto;
+		margin-right:auto;
+	}
+		#header
+		{
+			background:url("../imgs/header-f.jpg") 0 0 no-repeat #AF2A2A;
+			height:112px;
+		}
+			#header h1
+			{
+				margin:0;
+				padding:14px 0 9px 26px;
+				float:left;
+			}
+			#loginNavigation
+			{
+				float:right;
+			}
+				#loginNavigation ul
+				{
+					list-style-type:none;
+					font-size:11px;
+					margin:15px 25px 0 0;
+					padding:0;
+				}
+					#loginNavigation ul li
+					{
+						margin:0;
+						padding:0;
+					}
+						#loginNavigation li a
+						{
+							color:#FFFFFF;
+							text-decoration:none;
+						}
+							#loginNavigation li a:hover
+							{
+								text-decoration:underline;
+							}
+			#globalNavigation
+			{
+				clear:both;
+				padding-left:17px;
+				background:blue;
+				height:26px;
+			}
+			
+/**/			
+				#globalNavigation ul
+				{
+					list-style-type:none;
+					margin:0;
+					padding:0;
+				}
+					#globalNavigation ul li
+					{
+						float:left;
+						font-size:12px;
+						margin:0;
+						padding:0;
+					}
+						#globalNavigation li a
+						{
+							color:#FFFFFF;
+						}
+		#mainContent
+		{
+			background:url("../imgs/content-f.jpg") 0 0 repeat-y;
+		}
+			#contentNav
+			{
+			}
+			#mainContent h1,
+			#mainContent h2,
+			#mainContent h3,
+			#mainContent table,
+			#mainContent p
+			{
+				margin-left:25px;
+				margin-right:25px;
+				padding:0;
+			}
+				#mainContent h1
+				{
+					font-size:20px;
+					font-weight:normal;
+					color:#990000;
+					margin-top:0px;
+					margin-bottom:10px;
+				}
+				#mainContent h2,
+				#mainContent #config #configFile p
+				{
+					font-size:16px;
+					color:#666666;
+					margin-top:0px;
+					margin-bottom:5px;
+				}
+				#mainContent #config #configFile p
+				{
+					background:#EEEEEE;
+					color:#666666;
+					font-size:16px;
+				}
+				#mainContent h3
+				{
+					font-size:14px;
+					color:#999999;
+					margin-top:0px;
+					margin-bottom:0px;
+				}
+				#mainContent p,
+				form.quixote
+				{
+					color:#666666;
+					font-size:12px;
+					margin:25px;
+				}
+				#mainContent li
+				{
+					color:#666666;
+					font-size:12px;
+					margin:15px;
+				}
+
+				#mainContent ul
+				{
+				}
+				#mainContent a
+				{
+					color:#666666;
+				}
+					#mainContent a:hover
+					{
+						color:#990000;
+					}
+				/*Forms definitions*/
+				#mainContent form,
+				#mainContent form.quixote
+				{
+					padding:0px 25px 0px 25px;
+				}
+					#manContent table,
+					#mainContent form.quixote table
+					{
+						width:738px;
+					}
+						#mainContent table th,
+						#mainContent table td,
+						#mainContent form.quixote table th,
+						#mainContent form.quixote table td
+						{
+							padding:3px 5px 3px 5px;
+						}
+						#mainContent table thead th,
+						#mainContent #dump table th,
+						#mainContent form.quixote table thead th
+						{
+							background:#E7C3C3;
+							color:#990000;
+							font-size:11px;
+						}
+						#mainContent table tbody td,
+						#mainContent #dump table td,
+						#mainContent form.quixote table tbody td
+						{
+							background:#EEEEEE;
+							color:#666666;
+							font-size:11px;
+						}
+					#mainContent form p,
+					#mainContent form.quixote div.widget
+					{
+						margin-left:0;
+						margin-right:0;
+					}
+					#mainContent form.quixote input,
+					#mainContent form.quixote textarea,
+					#mainContent form.quixote select
+					{
+						font-family:Arial, Helvetica, sans-serif;
+						font-size:12px;
+						color:#333333;
+						background:#EEEEEE;
+						padding:1px 3px 1px 3px;
+						margin-left:0;
+						margin-right:0;
+					}
+					#mainContent .error,
+					div.error,
+					#mainContent .required,
+					span.required
+					{
+						font-family:Arial, Helvetica, sans-serif;
+						font-size:12px;
+						color:red;
+						padding:1px 3px 1px 3px;
+						margin-left:0;
+						margin-right:0;
+					}
+					/*#mainContent form.quixote div.submit div.SubmitWidget div.content,
+					{
+						font-family:Arial, Helvetica, sans-serif;
+						font-size:12px;
+						color:#333333;
+						background:#EEEEEE;
+						padding:1px 3px 1px 3px;
+					}*/
+					/*#mainContent form input.btn01,
+					#mainContent form.quixote div.submit div.SubmitWidget div.content,
+					#mainContent form input.btn02
+					{
+						border-width:1px;
+						border-style:solid;
+						font-size:11px;
+						font-weight:bold;
+						padding:1px 3px 1px 3px;
+					}
+						#mainContent form input.btn01,
+						#mainContent form.quixote div.submit div.SubmitWidget div.content
+						{
+							border-color:#9A0202;
+							background:#E7C3C3;
+							color:#990000;
+						}
+						#mainContent form input.btn02,
+						{
+							border-color:#676767;
+							background:#DBDBDB;
+							color:#333333;
+							font-size:10px;
+						}
+
+					#mainContent form input.noestilo
+					{
+						background:none;
+					}*/
+					#mainContent form.quixote select
+					{
+						padding:0;
+					}
+					/*#mainContent a.textBtn,
+					#mainContent form.quixote div.submit div.SubmitWidget,
+					{
+						padding:0 0 0 10px;
+						display:block;
+						background:url("../imgs/text-btn_f1.gif") left top no-repeat;
+						text-decoration:none;
+						font-weight:bold;
+						font-size:11px;
+					}
+						#mainContent a.textBtn span,
+						#mainContent form.quixote div.submit div.SubmitWidget,
+						{
+							padding:2px 10px 5px 0;
+							background:url("../imgs/text-btn_f2.gif") right top no-repeat;
+							display:block;
+							color:#990000;
+						}*/
+/**********************************/
+
+form.quixote .errornotice {
+	margin-bottom: 1em;
+	font-weight: bold;
+	color: #f00;
+	float: left;
+}
+
+form.quixote .title {
+	width: 16em;
+	float: left;
+	margin: 0 0.5em 10px 0;
+}
+
+form.quixote .required {
+	color: #f00;
+	padding: 0.4em;
+}
+
+form.quixote .submit {
+	clear: left;
+}
+
+form.quixote .content {
+	float: left;
+}
+
+form.quixote .content .error {
+	color: #f00;
+	display: inline;
+	font-weight: bold;
+	margin-left: 1em;
+}
+
+form.quixote .LabelWidget {
+	margin-top: 1em;
+	margin-bottom: 0.5em;
+	font-weight: bold;
+	font-size: 114%;
+	color: #336;
+	background-color: #f7f7f7;
+}
+
+form.quixote .SubmitWidget {
+	margin-top: 2em;
+	margin-right: 1em;
+	float: left;
+}
+
+
+
+form.quixote div.FormTokenWidget,
+form.quixote.div.HiddenWidget {
+	display: none;
+}
+
+form.quixote br {
+	clear: left;
+}
+/**********************************/
+		#footer
+		{
+			background:url("../imgs/footer-f.jpg") 0 bottom repeat-x;
+			height:60px;
+			text-align:right;
+		}
+			#footer p 
+			{
+				font-size:11px;
+				margin:7px 135px 10px auto;
+				padding:0;
+				color:#999999;
+			}
+				#footer p em
+				{
+					font-style:normal;
+					color:#990000;
+				}
+				#footer p a
+				{
+					color:#CCCCCC;
+				}
+					#footer p a:hover
+					{
+						color:#999999;
+					}
+		


Property changes on: trunk/static/themes/avatar/css/general.css
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/static/themes/avatar/imgs/body-f.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/body-f.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/btn-aceptar.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/btn-aceptar.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/btn-cancelar.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/btn-cancelar.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/btn-enviar.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/btn-enviar.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/content-f.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/content-f.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/contentnav-f.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/contentnav-f.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/footer-f.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/footer-f.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/header-f.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/header-f.jpg
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/icom-logo.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/icom-logo.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/menu-f1.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/menu-f1.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/menu-f2.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/menu-f2.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/submenu-f_bottom.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/submenu-f_bottom.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/submenu-f_top.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/submenu-f_top.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/text-btn_f1.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/text-btn_f1.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/static/themes/avatar/imgs/text-btn_f2.gif
===================================================================
(Binary files differ)


Property changes on: trunk/static/themes/avatar/imgs/text-btn_f2.gif
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream



From alerios at mail.berlios.de  Wed Dec 16 21:42:27 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Wed, 16 Dec 2009 21:42:27 +0100
Subject: [Destar-dev] r846 - trunk
Message-ID: <200912162042.nBGKgRFF021867@sheep.berlios.de>

Author: alerios
Date: 2009-12-16 21:42:23 +0100 (Wed, 16 Dec 2009)
New Revision: 846

Added:
   trunk/cfg_app_cidblock.py
Modified:
   trunk/CHANGELOG.txt
   trunk/cfg_app_agentcallbacklogin.py
   trunk/cfg_app_agentlogin.py
   trunk/cfg_app_callfw.py
   trunk/cfg_app_chanspy.py
   trunk/cfg_app_conference.py
   trunk/cfg_app_dnd.py
   trunk/cfg_app_meetme.py
   trunk/cfg_app_parking.py
   trunk/cfg_app_pickup.py
   trunk/cfg_app_quickdial_global.py
   trunk/cfg_app_quickdial_phone.py
   trunk/cfg_app_voicemail.py
   trunk/cfg_app_voicemailsettings.py
Log:
* cfg_app_*: separate context for all apps for security.
* Replaced CALLERIDNUM with CALLERID(num).
* Added cfg_app_cidblock.py to implement ex-girlfriend feature.



Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/CHANGELOG.txt	2009-12-16 20:42:23 UTC (rev 846)
@@ -1,3 +1,8 @@
+2009-12-16
+* cfg_app_*: separate context for all apps.
+* Replaced CALLERIDNUM with CALLERID(num).
+* Added cfg_app_cidblock.py to implement ex-girlfriend feature.
+
 2009-12-15
 * Added avatar web style
 

Modified: trunk/cfg_app_agentcallbacklogin.py
===================================================================
--- trunk/cfg_app_agentcallbacklogin.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_agentcallbacklogin.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -63,19 +63,19 @@
 		needModule("chan_local")
 	
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 
 		if self.silentlogin:
 			opts = "s"
 		else:
 			opts = ""
 		
-		c.appendExten(self.ext, "AgentCallbackLogin(${CALLERIDNUM}|%s|${CALLERIDNUM}@%s)" % (opts, self.pbx), self.pbx )
-		c.appendExten(self.ext, "DBdel(DND/%s/${CALLERIDNUM})" % self.pbx, self.pbx)
+		c.appendExten(self.ext, "AgentCallbackLogin(${CALLERID(num)},%s,${CALLERID(num)}@%s)" % (opts, self.pbx), self.pbx )
+		c.appendExten(self.ext, "DBdel(DND/%s/${CALLERID(num)})" % self.pbx, self.pbx)
 		c.appendExten(self.ext, "Playback(do-not-disturb)", self.pbx)
 		c.appendExten(self.ext, "Playback(cancelled)", self.pbx)
 		c.appendExten(self.ext, "Hangup", self.pbx)
 
-		c.appendExten(self.changeext, "AgentCallbackLogin(${CALLERIDNUM}|%s|'#')" % (opts), self.pbx )
+		c.appendExten(self.changeext, "AgentCallbackLogin(${CALLERID(num)},%s,'#')" % (opts), self.pbx )
 		c.appendExten(self.logoutext, "Dial(Local/%s@%s/n,,D(#))" % (self.changeext, self.pbx), self.pbx)
 

Modified: trunk/cfg_app_agentlogin.py
===================================================================
--- trunk/cfg_app_agentlogin.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_agentlogin.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -46,6 +46,6 @@
 		needModule("chan_agent")
 	
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 		c.appendExten(self.ext, "AgentLogin()", self.pbx)
 

Modified: trunk/cfg_app_callfw.py
===================================================================
--- trunk/cfg_app_callfw.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_callfw.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -68,15 +68,15 @@
 		if self.devstateprefix:
 		    needModule("app_devstate")
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 		c.appendExten(self.set, "Goto(cfw-%s,s,1)" % self.set, self.pbx)
 		c.appendExten(self.set, "Hangup", self.pbx)
 		c.appendExten("_%s." % self.set, "Macro(call-forward,%s,%s,${EXTEN:%d},%s)" % (self.type,self.pbx,len(self.set),msg), self.pbx)
 		c.appendExten("_%s." % self.set, "Hangup", self.pbx)
 		c.appendExten("%s" % self.unset, "Answer()", self.pbx)
-		c.appendExten("%s" % self.unset, "DBdel(%s/%s/${CALLERIDNUM})" % (self.type, self.pbx), self.pbx)
+		c.appendExten("%s" % self.unset, "DBdel(%s/%s/${CALLERID(num)})" % (self.type, self.pbx), self.pbx)
 		if self.devstateprefix:
-			c.appendExten("%s" % self.unset, "Devstate(%s_%s_${CALLERIDNUM},0)" % (self.type, self.pbx), self.pbx)
+			c.appendExten("%s" % self.unset, "Devstate(%s_%s_${CALLERID(num)},0)" % (self.type, self.pbx), self.pbx)
 		c.appendExten("%s" % self.unset, "Playback(call-fwd-cancelled)", self.pbx)
 		c.appendExten("%s" % self.unset, "Wait(1)", self.pbx)
 		c.appendExten("%s" % self.unset, "Hangup", self.pbx)
@@ -84,22 +84,23 @@
 		context="cfw-%s" % self.set
 		c.setSection(context)
 		if self.toggle:
-			c.appendExten("s", "Set(testcf=${DB(%s/%s/${CALLERIDNUM})})" % (self.type, self.pbx), context)
+			c.appendExten("s", "Set(testcf=${DB(%s/%s/${CALLERID(num)})})" % (self.type, self.pbx), context)
 			c.appendExten("s", 'GotoIf($["${testcf}" != ""]?switchoff)', context)	
 		c.appendExten("s", "Set(TIMEOUT(digit)=2)", context)
-		c.appendExten("s", "Set(lastnum=${DB(%s_LASTNUM/%s/${CALLERIDNUM})})" % (self.type, self.pbx), context)
+		c.appendExten("s", "Set(lastnum=${DB(%s_LASTNUM/%s/${CALLERID(num)})})" % (self.type, self.pbx), context)
 		c.appendExten("s", 'GotoIf($["${lastnum}" = ""]?nonumber)', context)
 		c.appendExten("s","Background(press-1&to-enter-a-number&or&press-2&for&vm-last&number)", context)
 		c.appendExten("s","WaitExten(3)", context)
 		c.appendExten("s","Hangup()", context)
 		c.appendExten("s", "Goto(1,1)", context, label="nonumber")
 		c.appendExten("s", "Goto(%s,%s,1)" % (self.pbx, self.unset), context, label="switchoff")
+		c.appendExten("i", "Goto(1,1)", context, label="nonumber")
 		c.appendExten("2","Macro(call-forward,%s,%s,${lastnum},%s)" % (self.type,self.pbx,msg), context)
 		if self.devstateprefix:
-			c.appendExten("2", "Devstate(%s_%s_${CALLERIDNUM},2)" % (self.type.lower(), self.pbx), context)
+			c.appendExten("2", "Devstate(%s_%s_${CALLERID(num)},2)" % (self.type.lower(), self.pbx), context)
 		c.appendExten("1", "Playback(please-enter-the&number&after-the-tone&beep)", context)
 		c.appendExten("1","WaitExten(5)", context)
 		c.appendExten("_X.","Macro(call-forward,%s,%s,${EXTEN},%s)" % (self.type,self.pbx,msg), context)
 		if self.devstateprefix:
-			c.appendExten("_X.", "Devstate(%s_%s_${CALLERIDNUM},2)" % (self.type.lower(), self.pbx), context)
+			c.appendExten("_X.", "Devstate(%s_%s_${CALLERID(num)},2)" % (self.type.lower(), self.pbx), context)
 

Modified: trunk/cfg_app_chanspy.py
===================================================================
--- trunk/cfg_app_chanspy.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_chanspy.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -30,10 +30,17 @@
 	def createVariables(self):
 		self.variables   = [ 
 			VarType("pbx",
-				title=_("Virtual PBX"),
+				title=_("Virtual PBX allowed to dial"),
 				type="choice",
+				optional = True,
 				options=getChoice("CfgOptPBX")),
 			
+			VarType("phone",
+				title = _("Phone allowed to dial"),
+				optional = True,
+				type ="choice",
+				options = getChoice("CfgPhone")),
+
 			VarType("ext",
 				title=_("Extension"),
 				len=6),
@@ -44,6 +51,11 @@
 				optional=True,
 				len=15),
 
+			VarType("spygroup",
+				title=_("Spy Group"),
+				optional=True,
+				len=15),
+
 			VarType("password",
 				type="int",
 				title=_("Password"),
@@ -62,10 +74,17 @@
 	def createAsteriskConfig(self):
 		needModule("app_chanspy")
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		if self.pbx:
+			c.setSection("%s-apps" % self.pbx)
+		else:
+			c.setSection("real-out-%s" % self.phone)
 		if self.password:
 			c.appendExten(self.ext, "Authenticate(%s)" % self.password, self.pbx)
 		if self.quiet:
-			c.appendExten(self.ext, "Chanspy(%s,q)" % self.scanspec, self.pbx)
-		else: 
-			c.appendExten(self.ext, "Chanspy(%s)" % self.scanspec, self.pbx)
+			quiet = "q"
+		else:
+			quiet = ""
+		if self.spygroup:
+			c.appendExten(self.ext, "Chanspy(,g(%s)%s)" % (self.spygroup,quiet), self.pbx)
+		else:
+			c.appendExten(self.ext, "Chanspy(%s,q%s" % (self.scanspec,quiet), self.pbx)

Added: trunk/cfg_app_cidblock.py
===================================================================
--- trunk/cfg_app_cidblock.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_cidblock.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -0,0 +1,50 @@
+# -*- coding: utf-8 -*-
+#
+# Destar has Copyright (C) 2005 by Holger Schurig
+# This file has Copyright (C) 2005 by Alejandro Rios
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+
+from configlets import *
+
+class CfgAppCIDBlocking(CfgApp):
+
+	shortName   = _("Caller Identifier Blocking List")
+	description = _("Extensions to add/remove from personal CID blocking list. The add extension will be of the form prefix+*+number_to_block. The remove extension will be of the form prefix+*+number_to_block.")
+	newObjectTitle = _("New extensions to add/remove/access personal CID blocking list")
+	
+	def createVariables(self):
+		self.variables   = [
+			VarType("pbx",    title=_("Virtual PBX"), type="choice", options=getChoice("CfgOptPBX")),
+			VarType("set",      title=_("Setting prefix"), len=6, default="*9"),
+			VarType("unset",   title=_("Unsetting prefix"), len=6, default="#9"),
+		       ]
+		self.dependencies = [ DepType("pbx", 
+					type="hard",
+					message = _("This is a Dependency")),
+					]
+	
+	def row(self):
+		return ("%s / %s" % (self.set,self.unset),self.shortName,self.pbx)
+
+	def createAsteriskConfig(self):
+		c = AstConf("extensions.conf")
+		c.setSection(self.pbx)
+		c.appendExten("_%s*X." % self.set, "Set(DB(CIDBLOCKLIST/${CALLERID(num)}/${EXTEN:%d})=${EXTEN:%d})" % (len(self.set)+1,len(self.set)+1))
+		c.appendExten("_%s*X." % self.set, "Hangup")
+		c.appendExten("_%s*X" % self.unset, "DBdel(CIDBLOCKLIST/${CALLERID(num)}/${EXTEN:%d})" % len(self.unset)+1)
+		c.appendExten("_%s*X" % self.unset, "Hangup")


Property changes on: trunk/cfg_app_cidblock.py
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/cfg_app_conference.py
===================================================================
--- trunk/cfg_app_conference.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_conference.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -40,7 +40,7 @@
 		needModule("app_conference")
 
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 		c.appendExten(self.ext, "Answer", self.pbx)
 		c.appendExten(self.ext, "Wait(1)", self.pbx)
 		c.appendExten(self.ext, "Conference", self.pbx)

Modified: trunk/cfg_app_dnd.py
===================================================================
--- trunk/cfg_app_dnd.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_dnd.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -61,8 +61,8 @@
 				if obj.tapi:
 				    tapisupport = True
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
-		c.appendExten("%s" % self.set, "Set(DB(DND/%s/${CALLERIDNUM})=True)" % self.pbx, self.pbx)
+		c.setSection("%s-apps" % self.pbx)
+		c.appendExten("%s" % self.set, "Set(DB(DND/%s/${CALLERID(num)})=True)" % self.pbx, self.pbx)
 		if tapisupport:
 			needModule("app_cut")
 			c.appendExten("%s" % self.set, "Set(CHAN=${CUT(CHANNEL,-,1)})", self.pbx)
@@ -72,7 +72,7 @@
 		c.appendExten("%s" % self.set, "Playback(activated)", self.pbx)
 		c.appendExten("%s" % self.set, "Hangup", self.pbx)
 
-		c.appendExten("%s" % self.unset, "DBdel(DND/%s/${CALLERIDNUM})" % self.pbx, self.pbx)
+		c.appendExten("%s" % self.unset, "DBdel(DND/%s/${CALLERID(num)})" % self.pbx, self.pbx)
 		if tapisupport:
 			c.appendExten("%s" % self.unset, "Set(CHAN=${CUT(CHANNEL,-,1)})", self.pbx)
 			c.appendExten("%s" % self.unset, "UserEvent(ASTDB,Channel: ${CHAN}^Family: DND^Value: ^)", self.pbx )

Modified: trunk/cfg_app_meetme.py
===================================================================
--- trunk/cfg_app_meetme.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_meetme.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -81,7 +81,7 @@
 		needModule("app_meetme")
 
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 		c.appendExten(self.ext, "Answer", self.pbx)
 		c.appendExten(self.ext, "Set(TIMEOUT(absolute)=%d)" % self.timeout, self.pbx)
 		# 'd' -- dynamically add conference
@@ -91,7 +91,7 @@
 			args += "%d" % self.confno
 		args += ",d"
 		if self.pin:
-			args += "P|%d" % self.pin
+			args += "P,%d" % self.pin
 		c.appendExten(self.ext, "MeetMe(%s)" % args, self.pbx)
 
 		if self.confno:

Modified: trunk/cfg_app_parking.py
===================================================================
--- trunk/cfg_app_parking.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_parking.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -49,7 +49,7 @@
 		# transferdigittimeout
 
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 		c.appendExten(self.ext, "Park(%s)" % self.ext, self.pbx)
 		
 		panelutils.createParkButton(self)

Modified: trunk/cfg_app_pickup.py
===================================================================
--- trunk/cfg_app_pickup.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_pickup.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -36,8 +36,7 @@
 			VarType("prefix",
 				title=_("Channel Pickup Prefix"),
 				len=6,
-				default="*8",
-				hint="needs bristuff patches (app_pickup.so)."),
+				default="*8")
 		       ]
 		self.dependencies = [ DepType("pbx", 
 					type="hard",
@@ -48,4 +47,8 @@
 		return ("%s" % (self.prefix), self.shortName, self.pbx)
 	
 	def createAsteriskConfig(self):
-		needModule("app_pickup")
+		needModule("app_directed_pickup")
+		c = AstConf("extensions.conf")
+		c.setSection("%s-apps" % self.pbx)
+		c.appendExten("_%s." % self.prefix, "Pickup(${EXTEN:%d}@PICKUPMARK)" % (len(self.prefix)), self.pbx)
+		c.appendExten("_%s." % self.prefix, "Hangup", self.pbx)

Modified: trunk/cfg_app_quickdial_global.py
===================================================================
--- trunk/cfg_app_quickdial_global.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_quickdial_global.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -56,7 +56,7 @@
 
 	def createAsteriskConfig(self):
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 		if self.pin:
 			needModule("app_authenticate")
 			c.appendExten("_%sXX*X." % self.set, "Authenticate(%s)" % self.pin, self.pbx)

Modified: trunk/cfg_app_quickdial_phone.py
===================================================================
--- trunk/cfg_app_quickdial_phone.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_quickdial_phone.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -44,8 +44,8 @@
 
 	def createAsteriskConfig(self):
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
-		c.appendExten("_%sXX*X." % self.set, "Set(DB(QUICKDIALLIST/${CALLERIDNUM}/${EXTEN:%d:2})=${EXTEN:%d})" % (len(self.set),len(self.set)+3), self.pbx)
+		c.setSection("%s-apps" % self.pbx)
+		c.appendExten("_%sXX*X." % self.set, "Set(DB(QUICKDIALLIST/${CALLERID(num)}/${EXTEN:%d:2})=${EXTEN:%d})" % (len(self.set),len(self.set)+3), self.pbx)
 		c.appendExten("_%sXX*X." % self.set, "Hangup", self.pbx)
-		c.appendExten("_%sXX" % self.unset, "DBdel(QUICKDIALLIST/${CALLERIDNUM}/${EXTEN:%d})" % len(self.unset), self.pbx)
+		c.appendExten("_%sXX" % self.unset, "DBdel(QUICKDIALLIST/${CALLERID(num)}/${EXTEN:%d})" % len(self.unset), self.pbx)
 		c.appendExten("_%sXX" % self.unset, "Hangup", self.pbx)

Modified: trunk/cfg_app_voicemail.py
===================================================================
--- trunk/cfg_app_voicemail.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_voicemail.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -47,7 +47,7 @@
 		c.appendExten(self.ext, "Answer", self.pbx)
 		c.appendExten(self.ext, "Wait(1)", self.pbx)
 		if not self.mailbox:
-			c.appendExten(self.ext, "VoiceMailMain(${CALLERIDNUM}@%s)" % self.pbx, self.pbx)
+			c.appendExten(self.ext, "VoiceMailMain(${CALLERID(num)}@%s)" % self.pbx, self.pbx)
 		else:
 			c.appendExten(self.ext, "VoiceMailMain(@%s)" % self.pbx, self.pbx)
 		c.appendExten(self.ext, "Hangup", self.pbx)

Modified: trunk/cfg_app_voicemailsettings.py
===================================================================
--- trunk/cfg_app_voicemailsettings.py	2009-12-15 22:50:03 UTC (rev 845)
+++ trunk/cfg_app_voicemailsettings.py	2009-12-16 20:42:23 UTC (rev 846)
@@ -69,14 +69,14 @@
 		if self.devstateprefix:
 		    needModule("app_devstate")
 		c = AstConf("extensions.conf")
-		c.setSection(self.pbx)
+		c.setSection("%s-apps" % self.pbx)
 		c.appendExten("%s" % self.set, "Answer()", self.pbx)
 		if self.toggle:
-			c.appendExten("%s" % self.set, "Set(togglestate=${DB(%s/%s/${CALLERIDNUM})})" % (self.type, self.pbx), self.pbx)
+			c.appendExten("%s" % self.set, "Set(togglestate=${DB(%s/%s/${CALLERID(num)})})" % (self.type, self.pbx), self.pbx)
 			c.appendExten("%s" % self.set, 'GotoIf($["${togglestate}" != ""]?switchoff)', self.pbx)
-		c.appendExten("%s" % self.set, "Set(DB(%s/%s/${CALLERIDNUM})=1)" % (self.type, self.pbx), self.pbx)
+		c.appendExten("%s" % self.set, "Set(DB(%s/%s/${CALLERID(num)})=1)" % (self.type, self.pbx), self.pbx)
 		if self.devstateprefix:
-			c.appendExten("%s" % self.set, "Devstate(%s_%s_${CALLERIDNUM},2)" % (self.type.lower(), self.pbx), self.pbx)
+			c.appendExten("%s" % self.set, "Devstate(%s_%s_${CALLERID(num)},2)" % (self.type.lower(), self.pbx), self.pbx)
 		if self.type == "VMIM":
 			c.appendExten("%s" % self.set, "Playback(voice-mail-system)", self.pbx)
 			c.appendExten("%s" % self.set, "Playback(activated)", self.pbx)
@@ -90,9 +90,9 @@
 		c.appendExten("%s" % self.set, "Hangup", self.pbx)
 		c.appendExten("%s" % self.set, "Goto(%s,%s,1)" % (self.pbx, self.ext), self.pbx, label="switchoff")
 		c.appendExten("%s" % self.ext, "Answer()", self.pbx)
-		c.appendExten("%s" % self.ext, "DBdel(%s/%s/${CALLERIDNUM})" % (self.type, self.pbx), self.pbx)
+		c.appendExten("%s" % self.ext, "DBdel(%s/%s/${CALLERID(num)})" % (self.type, self.pbx), self.pbx)
 		if self.devstateprefix:
-			c.appendExten("%s" % self.ext, "Devstate(%s_%s_${CALLERIDNUM},0)" % (self.type.lower(), self.pbx), self.pbx)
+			c.appendExten("%s" % self.ext, "Devstate(%s_%s_${CALLERID(num)},0)" % (self.type.lower(), self.pbx), self.pbx)
 		c.appendExten("%s" % self.ext, "Playback(voice-mail-system)", self.pbx)
 		c.appendExten("%s" % self.ext, "Playback(cancelled)", self.pbx)
 		c.appendExten("%s" % self.ext, "Wait(1)", self.pbx)



From alerios at mail.berlios.de  Thu Dec 17 00:23:10 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Thu, 17 Dec 2009 00:23:10 +0100
Subject: [Destar-dev] r847 - trunk
Message-ID: <200912162323.nBGNNAla000571@sheep.berlios.de>

Author: alerios
Date: 2009-12-17 00:23:10 +0100 (Thu, 17 Dec 2009)
New Revision: 847

Modified:
   trunk/CHANGELOG.txt
   trunk/cfg_opt_pbx.py
Log:
cfg_opt_pbx.py separate context for all apps.


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-16 20:42:23 UTC (rev 846)
+++ trunk/CHANGELOG.txt	2009-12-16 23:23:10 UTC (rev 847)
@@ -1,5 +1,5 @@
 2009-12-16
-* cfg_app_*: separate context for all apps.
+* cfg_opt_pbx.py cfg_app_*: separate context for all apps.
 * Replaced CALLERIDNUM with CALLERID(num).
 * Added cfg_app_cidblock.py to implement ex-girlfriend feature.
 

Modified: trunk/cfg_opt_pbx.py
===================================================================
--- trunk/cfg_opt_pbx.py	2009-12-16 20:42:23 UTC (rev 846)
+++ trunk/cfg_opt_pbx.py	2009-12-16 23:23:10 UTC (rev 847)
@@ -45,6 +45,8 @@
 		s = AstConf("extensions.conf")
 		s.setSection(self.name)
 		s.append(";Virtual PBX")
+		s.setSection("%s-apps" % self.name)
+		s.append(";Virtual PBX Applications")
 	
 	def row(self):
 		return (self.shortName,self.name)



From alerios at mail.berlios.de  Sun Dec 20 17:25:47 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 17:25:47 +0100
Subject: [Destar-dev] r848 - trunk
Message-ID: <200912201625.nBKGPlfL028406@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 17:25:46 +0100 (Sun, 20 Dec 2009)
New Revision: 848

Modified:
   trunk/CHANGELOG.txt
   trunk/page_admin_cfwstate.ptl
Log:
* page_admin_cfwstate.ptl: Added CFTO, VMU and VMBS.



Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-16 23:23:10 UTC (rev 847)
+++ trunk/CHANGELOG.txt	2009-12-20 16:25:46 UTC (rev 848)
@@ -1,5 +1,8 @@
+2009-12-20
+* page_admin_cfwstate.ptl: Added CFTO, VMU and VMBS.
+
 2009-12-16
-* cfg_opt_pbx.py cfg_app_*: separate context for all apps.
+* cfg_opt_pbx.py, cfg_app_*: separate context for all apps.
 * Replaced CALLERIDNUM with CALLERID(num).
 * Added cfg_app_cidblock.py to implement ex-girlfriend feature.
 

Modified: trunk/page_admin_cfwstate.ptl
===================================================================
--- trunk/page_admin_cfwstate.ptl	2009-12-16 23:23:10 UTC (rev 847)
+++ trunk/page_admin_cfwstate.ptl	2009-12-20 16:25:46 UTC (rev 848)
@@ -29,7 +29,10 @@
 def CFList [plain] (pbx):
 	cfimlist = manager.getVarFamily("CFIM/%s" % pbx)
 	cfbslist = manager.getVarFamily("CFBS/%s" % pbx)
+	cftolist = manager.getVarFamily("CFTO/%s" % pbx)
 	dndlist = manager.getVarFamily("DND/%s" % pbx)
+	vmulist = manager.getVarFamily("VMU/%s" % pbx)
+	vmbslist = manager.getVarFamily("VMBS/%s" % pbx)
 	if cfimlist != []:
 		# TODO: use CSS
 		'<table border=1 cellspacing="1">'
@@ -44,6 +47,21 @@
 		'<p><span class="errornotice">'
 		htmltext(_("No CFIM entries found"))
 		'</span></p>'
+	if cftolist != []:
+		# TODO: use CSS
+		'<table border=1 cellspacing="1">'
+		'<tbody><thead>'
+		'<tr><th>%s</th></tr>' % htmltext(_('Extension : CFTO Call Forwarning if Timeout')) 
+		'</thead>'
+		for i in cftolist:
+			'<tr><td>%s</td></tr>' % _(i)
+		'</tbody>'
+		'</table><br/><br/>'
+	else:
+		'<p><span class="errornotice">'
+		htmltext(_("No CFTO entries found"))
+		'</span></p>'
+
 	if cfbslist != []:
 		# TODO: use CSS
 		'<table border=1 cellspacing="1">'
@@ -72,6 +90,34 @@
 		'<p><span class="errornotice">'
 		htmltext(_("No DND entries found"))
 		'</span></p>'
+	if vmulist != []:
+		# TODO: use CSS
+		'<table border=1 cellspacing="1">'
+		'<tbody><thead>'
+		'<tr><th>%s</th></tr>' % htmltext(_('Extensions with active VMU')) 
+		'</thead>'
+		for i in vmulist:
+			'<tr><td>%s</td></tr>' % _(i)
+		'</tbody>'
+		'</table><br/><br/>'
+	else:
+		'<p><span class="errornotice">'
+		htmltext(_("No VMU entries found"))
+		'</span></p>'
+	if vmbslist != []:
+		# TODO: use CSS
+		'<table border=1 cellspacing="1">'
+		'<tbody><thead>'
+		'<tr><th>%s</th></tr>' % htmltext(_('Extensions with active VMBS')) 
+		'</thead>'
+		for i in vmbslist:
+			'<tr><td>%s</td></tr>' % _(i)
+		'</tbody>'
+		'</table><br/><br/>'
+	else:
+		'<p><span class="errornotice">'
+		htmltext(_("No VMBS entries found"))
+		'</span></p>'
 
 
 class Page(AccessControlled, Directory): 
@@ -81,7 +127,7 @@
 	_q_desc    = _("Call forwarding state")
 	_q_link    = 'cfwstate'
 	_q_menupos = 10
-	_q_level   = 2
+	_q_level   = 3
 
 	_q_exports = ['']
 



From alerios at mail.berlios.de  Sun Dec 20 17:28:22 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 17:28:22 +0100
Subject: [Destar-dev] r849 - trunk
Message-ID: <200912201628.nBKGSMqW028497@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 17:28:21 +0100 (Sun, 20 Dec 2009)
New Revision: 849

Modified:
   trunk/CHANGELOG.txt
   trunk/page_admin_pbxstate.ptl
Log:
* page_admin_pbxstate.ptl: changed table distribution


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 16:25:46 UTC (rev 848)
+++ trunk/CHANGELOG.txt	2009-12-20 16:28:21 UTC (rev 849)
@@ -1,5 +1,6 @@
 2009-12-20
 * page_admin_cfwstate.ptl: Added CFTO, VMU and VMBS.
+* page_admin_pbxstate.ptl: changed table distribution.
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Modified: trunk/page_admin_pbxstate.ptl
===================================================================
--- trunk/page_admin_pbxstate.ptl	2009-12-20 16:25:46 UTC (rev 848)
+++ trunk/page_admin_pbxstate.ptl	2009-12-20 16:28:21 UTC (rev 849)
@@ -106,10 +106,11 @@
 			h.setCell(x,y, formatChannel(obj, now) )
 			h.setAttr(x,y, id="phone")
 
-			y = y + 1
-			if y>=maxy:
-				x = x + 1
-				y = 0
+			x = x + 1
+			if x>=maxy:
+				y = y + 1
+				x = 0
 
 		h.getHtml(id='state', border=1)
+		#manager.getSIPPeers()
 		footer()



From alerios at mail.berlios.de  Sun Dec 20 18:32:03 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 18:32:03 +0100
Subject: [Destar-dev] r850 - trunk
Message-ID: <200912201732.nBKHW3oA000744@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 18:32:03 +0100 (Sun, 20 Dec 2009)
New Revision: 850

Modified:
   trunk/CHANGELOG.txt
   trunk/cfg_phone_ext.py
Log:
* cfg_phone_ext.py: in 1.6, set only accepts one variable at a time.


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 16:28:21 UTC (rev 849)
+++ trunk/CHANGELOG.txt	2009-12-20 17:32:03 UTC (rev 850)
@@ -1,6 +1,7 @@
 2009-12-20
 * page_admin_cfwstate.ptl: Added CFTO, VMU and VMBS.
 * page_admin_pbxstate.ptl: changed table distribution.
+* cfg_phone_ext.py: in 1.6, set only accepts one variable at a time.
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Modified: trunk/cfg_phone_ext.py
===================================================================
--- trunk/cfg_phone_ext.py	2009-12-20 16:28:21 UTC (rev 849)
+++ trunk/cfg_phone_ext.py	2009-12-20 17:32:03 UTC (rev 850)
@@ -98,9 +98,13 @@
 	def createAsteriskConfig(self):
 		extensions = AstConf("extensions.conf")
 		extensions.setSection(self.pbx)
-		extensions.appendExten(self.ext,"Set(CDR(pbx)=%s,CDR(userfield)=%s,CALLERID(num)=${CALLERIDNUM}-%s)" % (self.pbx,self.name,self.ext), self.pbx)
+		extensions.appendExten(self.ext,"Set(CDR(pbx)=%s)" % (self.pbx), self.pbx)
+		extensions.appendExten(self.ext,"Set(CDR(userfield)=%s)" % (self.name), self.pbx)
+		extensions.appendExten(self.ext,"Set(CALLERID(num)=${CALLERID(num)}-%s)" % (self.ext), self.pbx)
 		self.createDialEntry(extensions, self.ext, self.pbx, self.ext)
-		extensions.appendExten(self.name,"Set(CDR(pbx)=%s,CDR(userfield)=%s,CALLERID(num)=${CALLERIDNUM}-%s)" % (self.pbx,self.name,self.ext), self.pbx)
+		extensions.appendExten(self.name,"Set(CDR(pbx)=%s)" % (self.pbx), self.pbx)
+		extensions.appendExten(self.name,"Set(CDR(userfield)=%s)" % (self.name), self.pbx)
+		extensions.appendExten(self.name,"Set(CALLERID(num)=${CALLERID(num)}-%s)" % (self.ext), self.pbx)
 		self.createDialEntry(extensions, self.name, self.pbx, self.ext)
 		self.usemwi = False
 		self.createVoicemailConfig(extensions)



From alerios at mail.berlios.de  Sun Dec 20 18:49:05 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 18:49:05 +0100
Subject: [Destar-dev] r851 - trunk
Message-ID: <200912201749.nBKHn5xo009080@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 18:49:04 +0100 (Sun, 20 Dec 2009)
New Revision: 851

Modified:
   trunk/CHANGELOG.txt
   trunk/cfg_opt_voicemail.py
Log:
* cfg_opt_voicemail.py: change colon for pipe.


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 17:32:03 UTC (rev 850)
+++ trunk/CHANGELOG.txt	2009-12-20 17:49:04 UTC (rev 851)
@@ -2,6 +2,7 @@
 * page_admin_cfwstate.ptl: Added CFTO, VMU and VMBS.
 * page_admin_pbxstate.ptl: changed table distribution.
 * cfg_phone_ext.py: in 1.6, set only accepts one variable at a time.
+* cfg_opt_voicemail.py: change colon for pipe.
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Modified: trunk/cfg_opt_voicemail.py
===================================================================
--- trunk/cfg_opt_voicemail.py	2009-12-20 17:32:03 UTC (rev 850)
+++ trunk/cfg_opt_voicemail.py	2009-12-20 17:49:04 UTC (rev 851)
@@ -89,5 +89,5 @@
 
 		c.setSection("zonemessages")
 		# TODO: find out our own timezone somehow
-		c.append("cest=Europe/Berlin,'vm-received' Q 'digits/at' k 'oclock' M")
+		c.append("cest=Europe/Berlin|'vm-received' Q 'digits/at' k 'oclock' M")
 



From alerios at mail.berlios.de  Sun Dec 20 19:01:27 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 19:01:27 +0100
Subject: [Destar-dev] r852 - trunk
Message-ID: <200912201801.nBKI1Rdt020439@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 19:01:22 +0100 (Sun, 20 Dec 2009)
New Revision: 852

Modified:
   trunk/CHANGELOG.txt
   trunk/page_user_phonebook.ptl
Log:
* page_user_phonebook.ptl: catch an AttributeException.


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 17:49:04 UTC (rev 851)
+++ trunk/CHANGELOG.txt	2009-12-20 18:01:22 UTC (rev 852)
@@ -3,6 +3,7 @@
 * page_admin_pbxstate.ptl: changed table distribution.
 * cfg_phone_ext.py: in 1.6, set only accepts one variable at a time.
 * cfg_opt_voicemail.py: change colon for pipe.
+* page_user_phonebook.ptl: catch an AttributeException.
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Modified: trunk/page_user_phonebook.ptl
===================================================================
--- trunk/page_user_phonebook.ptl	2009-12-20 17:49:04 UTC (rev 851)
+++ trunk/page_user_phonebook.ptl	2009-12-20 18:01:22 UTC (rev 852)
@@ -63,9 +63,12 @@
 			if o.pbx == self.session.pbx or self.session.level >= 3 :
 				'<tr>'
 				'<td><a href="../dial/%s">%s</a></td>' % (o.ext, o.ext)
-				if o.calleridname:
-					'<td><a href="../dial/%s">%s</a></td>' % (o.ext, o.calleridname)
-				else:
+				try:
+					if o.calleridname:
+						'<td><a href="../dial/%s">%s</a></td>' % (o.ext, o.calleridname)
+					else:
+						'<td><a href="../dial/%s">%s</a></td>' % (o.ext, o.name)
+				except:
 					'<td><a href="../dial/%s">%s</a></td>' % (o.ext, o.name)
 				'</tr>'
 		'</table>'



From alerios at mail.berlios.de  Sun Dec 20 19:24:24 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 19:24:24 +0100
Subject: [Destar-dev] r853 - trunk
Message-ID: <200912201824.nBKIOOWF021121@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 19:24:11 +0100 (Sun, 20 Dec 2009)
New Revision: 853

Added:
   trunk/config.py
   trunk/sambautils.py
Modified:
   trunk/CHANGELOG.txt
   trunk/INSTALL.txt
   trunk/backend.py
   trunk/cfg_opt_user.py
Log:
* Added config.py to put general settings.
* backend.py:
 - Use config.py
 - VoiceMail has new sintax in 1.6
 - Added VICIDIAL_INTEGRATION option.
* cfg_opt_user.py: Added SAMBA_ENABLED option.
* Added sambautils.py



Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 18:01:22 UTC (rev 852)
+++ trunk/CHANGELOG.txt	2009-12-20 18:24:11 UTC (rev 853)
@@ -4,6 +4,13 @@
 * cfg_phone_ext.py: in 1.6, set only accepts one variable at a time.
 * cfg_opt_voicemail.py: change colon for pipe.
 * page_user_phonebook.ptl: catch an AttributeException.
+* Added config.py to put general settings.
+* backend.py:
+ - Use config.py
+ - VoiceMail has new sintax in 1.6
+ - Added VICIDIAL_INTEGRATION option.
+* cfg_opt_user.py: Added SAMBA_ENABLED option.
+* Added sambautils.py
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Modified: trunk/INSTALL.txt
===================================================================
--- trunk/INSTALL.txt	2009-12-20 18:01:22 UTC (rev 852)
+++ trunk/INSTALL.txt	2009-12-20 18:24:11 UTC (rev 853)
@@ -55,7 +55,16 @@
 	# dd if=/dev/urandom of=temp_file count=2; openssl dhparam -rand temp_file 512 >> destar.pem
 	# ln -sf destar.pem `openssl x509 -noout -hash < destar.pem`.0
 
+# Todo, document:
+Optional: Vicidial
+-----------------
+Optional: Samba
+-----------------
+Optional: OP-Panel
+-----------------
 
+
+
 Install Destar
 --------------
 

Modified: trunk/backend.py
===================================================================
--- trunk/backend.py	2009-12-20 18:01:22 UTC (rev 852)
+++ trunk/backend.py	2009-12-20 18:24:11 UTC (rev 853)
@@ -19,14 +19,12 @@
 
 
 import os
+from config import *
 import language
 import configlets
 import commands
 import re
 
-DESTAR_CFG = "destar_cfg.py"
-CONFIGLETS_DIR = os.getenv('CONFIGLETS_DIR', default='.') 
-ASTERISK_MODULES_DIR = os.getenv('ASTERISK_MODULES_DIR', default='/usr/lib/asterisk/modules')
 
 frontend_sessions = 0
 
@@ -160,9 +158,11 @@
 
 	c = AstConf("sip.conf")
 	c.append("language=%s" % getSetting('language', 'en'))
-	c.append("maxexpirey=3600")
-	c.append("defaultexpirey=3600")
+	c.append("maxexpiry=3600")
+	c.append("defaultexpiry=120")
 	c.append("disallow=all")
+	c.append("limitonpeers=yes")
+	c.append("t38pt_udptl = yes")
 
 	c = AstConf("iax.conf")
 	c.append("language=%s" % getSetting('language', 'en'))
@@ -238,7 +238,11 @@
                 c.append("exten=s,n,UserEvent(TAPI,TAPIEVENT: LINE_CALLSTATE LINECALLSTATE_OFFERING)")
                 c.append("exten=s,n,UserEvent(TAPI,TAPIEVENT: SET CALLERID ${CALLERID})")
                 c.append("exten=s,n,UserEvent(TAPI,TAPIEVENT: LINE_CALLINFO LINECALLINFOSTATE_CALLERID)")
-	c.append("exten=s,n(MainDial),Dial(${ARG1}${prng},${dsec},TtWwr${dopt})")
+	if VICIDIAL_INTEGRATION:
+		c.append("exten=s,n(MainDial),AGI(call_inbound.agi,${ARG1}-----${CALLERID}-----${CDR(intrunk)}-----x-----y-----z-----w)")
+		c.append("exten=s,n,Dial(${ARG1}${prng},${dsec},TtWwr${dopt})")
+	else:
+		c.append("exten=s,n(MainDial),Dial(${ARG1}${prng},${dsec},TtWwr${dopt})")
 	c.append(";")
 	c.append("; Dial result was 'timeout'")
 	c.append("exten=s,n(dialtimeout),Set(fw_ext=${DB(CFTO/${ARG4}/${ARG3})})")
@@ -266,17 +270,18 @@
 	c.append('exten=s,n,GotoIf($["${vmbs}" != ""]?vmbs)')
 	c.append("exten=s,n,Answer()")
 	c.append("exten=s,n,PlayTones(busy)")
-	c.append("exten=s,n,Busy()")
+	#c.append("exten=s,n,Busy()")
+	c.append("exten=s,n,Hangup()")
 	c.append(";")
 	c.append("exten=s,n(fw),Set(cf_count=$[${cf_count} + 1])")
 	c.append("exten=s,n,Set(CALLERID(num)=${CALLERID(num)}-${ARG3})")
 	c.append("exten=s,n,Goto(real-${ARG2},${fw_ext},1)")
 	c.append(";")
 	c.append('exten=s,n(vmu),Set(vmopt=u)')
-	c.append("exten=s,n,Macro(voicemail,${vmopt}${ARG3},${ARG4})")
+	c.append("exten=s,n,Macro(voicemail,${ARG3},${ARG4},${vmopt})")
 	c.append(";")
 	c.append('exten=s,n(vmbs),Set(vmopt=b)')
-	c.append("exten=s,n,Macro(voicemail,${vmopt}${ARG3},${ARG4})")
+	c.append("exten=s,n,Macro(voicemail,${ARG3},${ARG4},${vmopt})")
 	c.append(";")
 	c.append("exten=s,n(hangup),Hangup()")
 	c.append(";")
@@ -297,9 +302,9 @@
 	c.append("exten => t,1,Hangup()")
 	c.append("exten => T,1,Hangup()")
 	c.append("exten => s,1,Answer")
-	c.append("exten => s,2,Set(TIMEOUT(absolute)=240)")
+	c.append("exten => s,2,Set(TIMEOUT(absolute)=7200)")
 	c.append("exten => s,3,Wait(1)")
-	c.append("exten => s,4,VoiceMail(${ARG1}@${ARG2})")
+	c.append("exten => s,4,VoiceMail(${ARG1}@${ARG2},${ARG3})")
 	c.append("exten => s,5,Hangup()")
 
 	c.append(";")
@@ -307,23 +312,25 @@
 	c.append(";")
 	needModule("app_fax")
 	context="macro-sendfax"
+	context="faxout"
 	c.setSection(context)
 	c.appendExten("s", "Answer()", context)
 	c.appendExten("s", "Wait(${ARG2})", context)
-        c.appendExten("s", "Set(LOCALSTATIONID=%s)" getSetting('header_text', 'DeStar PBX'), context)
-        c.appendExten("s", "SendFAX(${FAXFILE})", context)
+	c.appendExten("s", "Set(LOCALSTATIONID=%s)" getSetting('header_text', 'DeStar PBX'), context)
+	c.appendExten("s", "SendFAX(${FAXFILE})", context)
 	c.appendExten("s", "Hangup", context)
-        c.appendExten("h", "NoOp(TX: REMOTESTATIONID is ${REMOTESTATIONID})", context)
+	c.appendExten("h", "NoOp(TX: REMOTESTATIONID is ${REMOTESTATIONID})", context)
 	c.appendExten("h", "UserEvent(FAX|SEND: Call ended normally)", context)
 
+
 	c.append(";")
 	c.append("; format: Macro(call-forward,type,pbx,destination,message-to-play)")
 	c.append(";")
 	context="macro-call-forward"
 	c.setSection(context)
 	c.appendExten("s", "Answer()", context)
-	c.appendExten("s", "Set(DB(${ARG1}/${ARG2}/${CALLERIDNUM})=${ARG3})", context)
-	c.appendExten("s", "Set(DB(${ARG1}_LASTNUM/${ARG2}/${CALLERIDNUM})=${ARG3})", context)
+	c.appendExten("s", "Set(DB(${ARG1}/${ARG2}/${CALLERID(num)})=${ARG3})", context)
+	c.appendExten("s", "Set(DB(${ARG1}_LASTNUM/${ARG2}/${CALLERID(num)})=${ARG3})", context)
 	c.appendExten("s", "Playback(${ARG4})", context)
 	c.appendExten("s", "Playback(has-been-set-to)", context)
 	c.appendExten("s", "SayDigits(${ARG3})", context)
@@ -437,7 +444,16 @@
 	c.append("exten => T,2,Wait(5)")
 	c.append("exten => T,3,Hangup")
 
+	if SAMBA_ENABLED:
+		c = AstConf("smb.conf")
+		c.setSection("global")
+		c.append("workgroup = DeStarPBX")
+		c.append("server string = DeStarPBX")
+		c.append("log file = /var/log/samba/log.%m")
+		c.append("security = user")
+		c.append("socket options = TCP_NODELAY SO_RCVBUF=8192 SO_SNDBUF=8192")
 
+
 def createAsteriskConfig():
 	"""This creates all the Asterisk config files in /etc/asterisk.
 

Modified: trunk/cfg_opt_user.py
===================================================================
--- trunk/cfg_opt_user.py	2009-12-20 18:01:22 UTC (rev 852)
+++ trunk/cfg_opt_user.py	2009-12-20 18:24:11 UTC (rev 853)
@@ -17,7 +17,9 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 #
 
+from config import *
 import language
+import sambautils
 from configlets import *
 
 class CfgOptUser(CfgOpt):
@@ -30,14 +32,13 @@
 		self.variables = [
 		VarType("name",   title=_("Name"), len=15),
 		VarType("secret", title=_("Password"), len=15),
-		VarType("pc",     title=_("Associated IP address of PC"), hint=_("Trusted for auto-login"), len=15, optional=True),
 		VarType("phone",  title=_("Associated phone"), type="choice", optional=True,
 		                  options=getChoice("CfgPhone")),
 		VarType("pbx",	  title=_("Associated Virtual PBX"), type="choice", optional=True, options=getChoice("CfgOptPBX")),
 		VarType("level",  title=_("Type"), type="choice",
 		                  options=( ("0",_("disabled")),
 		                            ("1",_("User")),
-		                            ("2",_("Virtual PBX Administrator")),
+		                            ("2",_("Report Manager")),
 		                            ("3",_("Configurator")) )),
 		VarType("language", title=_("Language"), type="choice",
 				    options=( ("en","en"),
@@ -60,14 +61,30 @@
 		for obj in configlets.configlet_tree:
 			if obj==self: 
 				continue
-			try:
-				if self.level == "2" and not self.pbx:
-					return ("pbx", _("Please choose a Virtual PBX for this user."))
-			except AttributeError:
-				pass
+			#try:
+			#	if self.level == "2" and not self.pbx:
+			#		return ("pbx", _("Please choose a Virtual PBX for this user."))
+			#except AttributeError:
+			#	pass
 
 	def createAsteriskConfig(self):
 		pass
+		if int(self.level) == 3 and config.SAMBA_ENABLED:
+			c = AstConf("smb.conf")
+			c.setSection("%s-spool" % self.name)
+			c.append("path = /var/spool/asterisk/")
+			c.append("valid users = %s" % self.name)
+			c.append("force user = root")
+                        c.append("read only = no")
 
+			c.setSection("%s-share" % self.name)
+			c.append("path = /usr/share/asterisk/")
+			c.append("valid users = %s" % self.name)
+			c.append("force user = root")
+                        c.append("read only = no")
+
+			sambautils.setPassword(self.name, self.secret)
+			sambautils.restartDaemon()
+
 	def row(self):
 		return (self.shortName, self.name)

Added: trunk/config.py
===================================================================
--- trunk/config.py	2009-12-20 18:01:22 UTC (rev 852)
+++ trunk/config.py	2009-12-20 18:24:11 UTC (rev 853)
@@ -0,0 +1,50 @@
+#!/usr/bin/python
+#-*- coding: utf-8 -*-
+#
+# Global variables used by destar
+#
+import os
+
+# - DESTAR SETTINGS
+
+DESTAR_CFG = "destar_cfg.py"
+
+CONFIGLETS_DIR = os.getenv('CONFIGLETS_DIR', default='.') 
+
+DOC_DIR = os.getenv('DESTAR_DOC_DIR', default='/tmp/destar-doc')
+
+CONF_TAG = "; Automatically created by DESTAR\n"
+
+MAXSECRETLENGTH = 45
+
+# -  ASTERISK PATHS
+
+CONF_DIR = "/etc/asterisk"
+
+ASTERISK_MODULES_DIR = os.getenv('ASTERISK_MODULES_DIR', default='/usr/lib/asterisk/modules') 
+
+# - MYSQL INFO
+
+DBHOST = "172.30.0.4"
+DBNAME = "asterisk"
+DBUSER = "root"
+DBPASSWD = "q931avt+-"
+
+# - FLASH OPERATOR PANEL SETTINGS
+
+# Uncomment to use with asternic.org op_panel tarball:
+#PANEL_CONF_DIR	= "/usr/local/op_panel"
+#PANEL_HTML_DIR	= "/usr/local/op_panel/flash"
+#PANEL_RESTART_CMD = "killall -HUP op_server.pl"
+
+# Uncomment to use with op-panel .deb package:
+PANEL_CONF_DIR	= "/etc/op-panel"
+PANEL_HTML_DIR	= "/usr/share/op-panel/flash"
+PANEL_RESTART_CMD = "killall -HUP op_server"
+
+
+# - OTHER APPS INTEGRATION
+
+VICIDIAL_INTEGRATION = 0
+SAMBA_ENABLED = 0
+SAMBA_RESTART_CMD = "/etc/init.d/samba reload"

Added: trunk/sambautils.py
===================================================================
--- trunk/sambautils.py	2009-12-20 18:01:22 UTC (rev 852)
+++ trunk/sambautils.py	2009-12-20 18:24:11 UTC (rev 853)
@@ -0,0 +1,38 @@
+# -*- coding: utf-8 -*-
+#
+# Copyright (C) 2005 by Diego Andr?s Asenjo
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+import os, commands
+from config import *
+
+def restartDaemon():
+        return commands.getoutput(SAMBA_RESTART_CMD)
+
+def setPassword(user, pswd):
+	(stat, out) = commands.getstatusoutput("id %s" % user)
+	if stat:
+		os.popen("useradd %s" % user)
+			
+	p = os.popen("smbpasswd -s -a %s" % user, 'w')
+	p.write(pswd+"\n")
+	p.write(pswd+"\n")
+
+def deleteUser(name):
+	os.popen("smbpasswd -x %s" % name)
+	os.popen("userdel %s" % name)
+	



From alerios at mail.berlios.de  Sun Dec 20 20:42:40 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 20:42:40 +0100
Subject: [Destar-dev] r854 - trunk
Message-ID: <200912201942.nBKJgepf025362@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 20:42:40 +0100 (Sun, 20 Dec 2009)
New Revision: 854

Modified:
   trunk/CHANGELOG.txt
   trunk/cfg_phone_zap.py
Log:
* cfg_phone_zap.py: added missing monitorinbound variable.


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 18:24:11 UTC (rev 853)
+++ trunk/CHANGELOG.txt	2009-12-20 19:42:40 UTC (rev 854)
@@ -11,6 +11,7 @@
  - Added VICIDIAL_INTEGRATION option.
 * cfg_opt_user.py: Added SAMBA_ENABLED option.
 * Added sambautils.py
+* cfg_phone_zap.py: added missing monitorinbound variable.
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Modified: trunk/cfg_phone_zap.py
===================================================================
--- trunk/cfg_phone_zap.py	2009-12-20 18:24:11 UTC (rev 853)
+++ trunk/cfg_phone_zap.py	2009-12-20 19:42:40 UTC (rev 854)
@@ -145,6 +145,12 @@
 					optional=True,
 					type="bool"),
 
+			VarType("monitorinbound",
+					title=_("Monitor calls made to this extension?"),
+					optional=True,
+					default=False,
+					type="bool"),
+
 			VarType("monitorfilename",
 					title=_("Monitor file name"),
 					hint=_("Otherwise it will use Date-CallerIdName(CallerIdNum)-Exten"),



From alerios at mail.berlios.de  Sun Dec 20 22:44:21 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 22:44:21 +0100
Subject: [Destar-dev] r855 - in trunk: . dahdi-gen dahdi-gen/Dahdi
	dahdi-gen/Dahdi/Config dahdi-gen/Dahdi/Config/Gen
	dahdi-gen/Dahdi/Hardware dahdi-gen/Dahdi/Xpp
Message-ID: <200912202144.nBKLiLeL005778@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 22:44:13 +0100 (Sun, 20 Dec 2009)
New Revision: 855

Added:
   trunk/dahdi-gen/
   trunk/dahdi-gen/Dahdi.pm
   trunk/dahdi-gen/Dahdi/
   trunk/dahdi-gen/Dahdi/Chans.pm
   trunk/dahdi-gen/Dahdi/Config/
   trunk/dahdi-gen/Dahdi/Config/Gen.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/
   trunk/dahdi-gen/Dahdi/Config/Gen/Chandahdi.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/Modules.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/System.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/Unicall.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/Users.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/Xpporder.pm
   trunk/dahdi-gen/Dahdi/Config/Params.pm
   trunk/dahdi-gen/Dahdi/Hardware.pm
   trunk/dahdi-gen/Dahdi/Hardware/
   trunk/dahdi-gen/Dahdi/Hardware/PCI.pm
   trunk/dahdi-gen/Dahdi/Hardware/USB.pm
   trunk/dahdi-gen/Dahdi/Span.pm
   trunk/dahdi-gen/Dahdi/Utils.pm
   trunk/dahdi-gen/Dahdi/Xpp.pm
   trunk/dahdi-gen/Dahdi/Xpp/
   trunk/dahdi-gen/Dahdi/Xpp/Line.pm
   trunk/dahdi-gen/Dahdi/Xpp/Mpp.pm
   trunk/dahdi-gen/Dahdi/Xpp/Xbus.pm
   trunk/dahdi-gen/Dahdi/Xpp/Xpd.pm
   trunk/dahdi-gen/dahdi_genconf
Modified:
   trunk/CHANGELOG.txt
Log:
* Added dahdi-gen and created dahdi-gen/Dahdi/Config/Gen/Destar.pm
  as a proof-of-concept (thanks tzafrir).



Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/CHANGELOG.txt	2009-12-20 21:44:13 UTC (rev 855)
@@ -12,6 +12,8 @@
 * cfg_opt_user.py: Added SAMBA_ENABLED option.
 * Added sambautils.py
 * cfg_phone_zap.py: added missing monitorinbound variable.
+* Added dahdi-gen and created dahdi-gen/Dahdi/Config/Gen/Destar.pm
+  as a proof-of-concept (thanks tzafrir).
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Added: trunk/dahdi-gen/Dahdi/Chans.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Chans.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Chans.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,260 @@
+package Dahdi::Chans;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Chans.pm 6613 2009-05-13 10:37:08Z tzafrir $
+#
+use strict;
+use Dahdi::Utils;
+
+=head1 NAME
+
+Dahdi::Chans - Perl interface to a Dahdi channel information
+
+This package allows access from perl to information about a Dahdi
+channel. It is part of the Dahdi Perl package.
+
+=head1 alarms()
+
+In an array context returns a list of alarm strings (RED, BLUE, etc.)
+for this channel (an empty list == false if there are no alarms).
+In scalar context returns the number of alarms for a specific channel.
+
+=head1 battery()
+
+Returns 1 if channel reports to have battery (A remote PBX connected to
+an FXO port), 0 if channel reports to not have battery and C<undef>
+otherwise.
+
+Currently only wcfxo and Astribank FXO modules report battery. For the
+rest of the channels 
+
+=head1 fqn()
+
+(Fully Qualified Name) Returns the full "name" of the channel.
+
+=head1 index()
+
+Returns the number of this channel (in the span).
+
+=head1 num()
+
+Returns the number of this channel as a Dahdi channel.
+
+=head signalling()
+
+Returns the signalling set for this channel through /etc/dahdi/system.conf .
+This is always empty before dahdi_cfg was run. And shows the "other" type
+for FXS and for FXO.
+
+=head1 span()
+
+Returns a reference to the span to which this channel belongs.
+
+=head1 type()
+
+Returns the type of the channel: 'FXS', 'FXO', 'EMPTY', etc.
+
+=cut
+
+my @alarm_types = qw(BLUE YELLOW RED LOOP RECOVERING NOTOPEN);
+
+# Taken from dahdi-base.c
+my @sigtypes = (
+	"FXSLS",
+	"FXSKS",
+	"FXSGS",
+	"FXOLS",
+	"FXOKS",
+	"FXOGS",
+	"E&M",
+	"E&M-E1",
+	"Clear",
+	"HDLCRAW",
+	"HDLCFCS",
+	"HDLCNET",
+	"Hardware-assisted HDLC",
+	"MTP2",
+	"Slave",
+	"CAS",
+	"DACS",
+	"DACS+RBS",
+	"SF (ToneOnly)",
+	"Unconfigured"
+	);
+
+sub new($$$$$$) {
+	my $pack = shift or die "Wasn't called as a class method\n";
+	my $span = shift or die "Missing a span parameter\n";
+	my $index = shift;
+	my $line = shift or die "Missing an input line\n";
+	defined $index or die "Missing an index parameter\n";
+	my $self = {
+			'SPAN' => $span,
+			'INDEX' => $index,
+		};
+	bless $self, $pack;
+	my ($num, $fqn, $rest) = split(/\s+/, $line, 3);
+	$num or die "Missing a channel number parameter\n";
+	$fqn or die "Missing a channel fqn parameter\n";
+	my $signalling = '';
+	my @alarms = ();
+	my $info = '';
+	if(defined $rest) {
+		# remarks in parenthesis (In use), (no pcm)
+		while($rest =~ s/\s*(\([^)]+\))\s*/ /) {
+			$info .= " $1";
+		}
+		# Alarms
+		foreach my $alarm (@alarm_types) {
+			if($rest =~ s/\s*(\b${alarm}\b)\s*/ /) {
+				push(@alarms, $1);
+			}
+		}
+		foreach my $sig (@sigtypes) {
+			if($rest =~ s/^\Q$sig\E/ /) {
+				$signalling = $sig;
+				last;
+			}
+		}
+		warn "Unrecognized garbage '$rest' in $fqn\n"
+			if $rest =~ /\S/;
+	}
+	$self->{NUM} = $num;
+	$self->{FQN} = $fqn;
+	$self->{SIGNALLING} = $signalling;
+	$self->{ALARMS} = \@alarms;
+	$self->{INFO} = $info;
+	my $type;
+	if($fqn =~ m|\bXPP_(\w+)/.*$|) {
+		$type = $1;		# An Astribank
+	} elsif ($fqn =~ m{\bWCFXO/.*}) {
+		$type = "FXO"; # wcfxo - x100p and relatives.
+		# A single port card. The driver issue RED alarm when
+		# There's no better
+		$self->{BATTERY} = !($span->description =~ /\bRED\b/);
+	} elsif ($fqn =~ m{\bFXS/.*}) {
+		$type = "FXS"; # likely Rhino
+	} elsif ($fqn =~ m{\bFXO/.*}) {
+		$type = "FXO"; # likely Rhino
+	} elsif ($fqn =~ m{---/.*}) {
+		$type = "EMPTY"; # likely Rhino, empty slot.
+	} elsif ($fqn =~ m{\b(TE[24]|WCT1|Tor2|TorISA|WP[TE]1|cwain[12]|R[124]T1)/.*}) {
+		# TE[24]: Digium wct4xxp
+		# WCT1: Digium single span card drivers?
+		# Tor2: Tor PCI cards
+		# TorISA: ISA ones (still used?) 
+		# WP[TE]1: Sangoma. TODO: this one tells us if it is TE or NT.
+		# cwain: Junghanns E1 card.
+		# R[124]: Rhino r1t1/rxt1 cards
+		$type = "PRI";
+	} elsif ($fqn =~ m{\b(B4|ZTHFC\d*|ztqoz\d*)/.*}) {
+		# B4: The Digium wcb4xxp DAHDI driver
+		# ZTHFC: HFC-s single-port card (zaphfc/vzaphfc)
+		# ztqoz: qozap (Junghanns) multi-port HFC card
+		$type = "BRI";
+        } elsif ($fqn =~ m{\bDYN/.*}) {
+                # DYN : Dynamic span (TDMOE)
+                $type = "DYN"
+	} elsif ($fqn =~ m{\bztgsm/.*}) {
+		# Junghanns GSM card
+		$type = "GSM";
+	} elsif($signalling ne '') {
+		$type = 'FXO' if $signalling =~ /^FXS/;
+		$type = 'FXS' if $signalling =~ /^FXO/;
+	} else {
+		$type = $self->probe_type();
+	}
+	$self->type($type);
+	$self->span()->type($type)
+		if ! defined($self->span()->type()) ||
+			$self->span()->type() eq 'UNKNOWN';
+	return $self;
+}
+
+=head1 probe_type()
+
+In the case of some cards, the information in /proc/dahdi is not good
+enough to tell the type of each channel. In this case an extra explicit
+probe is needed.
+
+Currently this is implemented by using some invocations of dahdi_cfg(8).
+
+It may later be replaced by dahdi_scan(8).
+
+=cut
+
+my $dahdi_cfg = $ENV{DAHDI_CFG} || '/usr/sbin/dahdi_cfg';
+sub probe_type($) {
+	my $self = shift;
+	my $fqn = $self->fqn;
+	my $num = $self->num;
+	my $type;
+
+	if($fqn =~ m:WCTDM/|WRTDM/|OPVXA1200/:) {
+		my %maybe;
+
+		undef %maybe;
+		foreach my $sig (qw(fxo fxs)) {
+			my $cmd = "echo ${sig}ks=$num | $dahdi_cfg -c /dev/fd/0";
+
+			$maybe{$sig} = system("$cmd >/dev/null 2>&1") == 0;
+		}
+		if($maybe{fxo} and $maybe{fxs}) {
+			$type = 'EMPTY';
+		} elsif($maybe{fxo}) {
+			$type = 'FXS';
+		} elsif($maybe{fxs}) {
+			$type = 'FXO';
+		} else {
+			$type = 'EMPTY';
+		}
+	} else {
+		$type = $self->type;
+	}
+	return $type;
+}
+
+sub battery($) {
+	my $self = shift or die;
+	my $span = $self->span or die;
+
+	return undef unless defined $self->type && $self->type eq 'FXO';
+	return $self->{BATTERY} if defined $self->{BATTERY};
+
+	my $xpd = $span->xpd;
+	my $index = $self->index;
+	return undef if !$xpd;
+
+	# It's an XPD (FXO)
+	my @lines = @{$xpd->lines};
+	my $line = $lines[$index];
+	return $line->battery;
+}
+
+sub alarms($) {
+	my $self = shift or die;
+	my @alarms = @{$self->{ALARMS}};
+
+	return @alarms;
+}
+
+sub blink($$) {
+	my $self = shift or die;
+	my $on = shift;
+	my $span = $self->span or die;
+
+	my $xpd = $span->xpd;
+	my $index = $self->index;
+	return undef if !$xpd;
+
+	my @lines = @{$xpd->lines};
+	my $line = $lines[$index];
+	return $line->blink($on);
+}
+
+
+1;

Added: trunk/dahdi-gen/Dahdi/Config/Gen/Chandahdi.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/Chandahdi.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/Chandahdi.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,215 @@
+package Dahdi::Config::Gen::Chandahdi;
+use strict;
+
+use Dahdi::Config::Gen qw(is_true);
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $gconfig = shift || die;
+	my $genopts = shift || die;
+	my $file = $ENV{CHAN_DAHDI_CHANNELS_FILE} || "/etc/asterisk/dahdi-channels.conf";
+	my $self = {
+			FILE	=> $file,
+			GCONFIG	=> $gconfig,
+			GENOPTS	=> $genopts,
+		};
+	bless $self, $pack;
+	return $self;
+}
+
+# Since chan_dahdi definitions "leak" to the next ones, we try
+# To reset some important definitions to their chan_dahdi defaults.
+my %chan_dahdi_defaults = (
+	context => 'default',
+	group => '63', # FIXME: should not be needed. 
+	overlapdial => 'no',
+	busydetect => 'no',
+	rxgain => 0,
+	txgain => 0,
+);
+
+sub reset_chandahdi_values {
+	foreach my $arg (@_) {
+		if (exists $chan_dahdi_defaults{$arg}) {
+			print "$arg = $chan_dahdi_defaults{$arg}\n";
+		} else {
+			print "$arg =\n";
+		}
+	}
+}
+
+sub gen_digital($$) {
+	my $self = shift || die;
+	my $span = shift || die;
+	my $gconfig = $self->{GCONFIG};
+	my $num = $span->num() || die;
+	die "Span #$num is analog" unless $span->is_digital();
+	if($span->is_pri && $gconfig->{'pri_connection_type'} eq 'R2') {
+		printf "; Skipped: $gconfig->{'pri_connection_type'}\n\n";
+		return;
+	}
+	my $type = $span->type() || die "$0: Span #$num -- unkown type\n";
+	my $termtype = $span->termtype() || die "$0: Span #$num -- unkown termtype [NT/TE]\n";
+	my $group = $gconfig->{'group'}{"$type"};
+	my $context = $gconfig->{'context'}{"$type"};
+	my @to_reset = qw/context group/;
+
+	die "$0: missing default group (termtype=$termtype)\n" unless defined($group);
+	die "$0: missing default context\n" unless $context;
+
+	my $sig = $span->signalling || die "missing signalling info for span #$num type $type";
+	grep($gconfig->{'bri_sig_style'} eq $_, 'bri', 'bri_ptmp', 'pri') or die "unknown signalling style for BRI";
+	if($span->is_bri() and $gconfig->{'bri_sig_style'} eq 'bri_ptmp') {
+		$sig .= '_ptmp';
+	}
+	if ($span->is_bri() && $termtype eq 'NT' && is_true($gconfig->{'brint_overlap'})) {
+		print "overlapdial = yes\n";
+		push(@to_reset, qw/overlapdial/);
+	}
+		
+	$group .= "," . (10 + $num);	# Invent unique group per span
+	printf "group=$group\n";
+	printf "context=$context\n";
+	printf "switchtype = %s\n", $span->switchtype;
+	printf "signalling = %s\n", $sig;
+	printf "channel => %s\n", Dahdi::Config::Gen::bchan_range($span);
+	reset_chandahdi_values(@to_reset);
+}
+
+sub gen_channel($$) {
+	my $self = shift || die;
+	my $chan = shift || die;
+	my $gconfig = $self->{GCONFIG};
+	my $type = $chan->type;
+	my $num = $chan->num;
+	die "channel $num type $type is not an analog channel\n" if $chan->span->is_digital();
+	my $exten = $gconfig->{'base_exten'} + $num;
+	my $sig = $gconfig->{'chan_dahdi_signalling'}{$type};
+	my $context = $gconfig->{'context'}{$type};
+	my $group = $gconfig->{'group'}{$type};
+	my $callerid;
+	my $immediate;
+
+	return if $type eq 'EMPTY';
+	die "missing default_chan_dahdi_signalling for chan #$num type $type" unless $sig;
+	$callerid = ($type eq 'FXO')
+			? 'asreceived'
+			: sprintf "\"Channel %d\" <%04d>", $num, $exten;
+	if($type eq 'IN') {
+		$immediate = 'yes';
+	}
+	# FIXME: $immediage should not be set for 'OUT' channels, but meanwhile
+	#        it's better to be compatible with genzaptelconf
+	$immediate = 'yes' if $gconfig->{'fxs_immediate'} eq 'yes' and $sig =~ /^fxo_/;
+	my $signalling = $chan->signalling;
+	$signalling = " " . $signalling if $signalling;
+	my $info = $chan->info;
+	$info = " " . $info if $info;
+	printf ";;; line=\"%d %s%s%s\"\n", $num, $chan->fqn, $signalling, $info;
+	printf "signalling=$sig\n";
+	printf "callerid=$callerid\n";
+	printf "mailbox=%04d\n", $exten unless $type eq 'FXO';
+	if(defined $group) {
+		printf "group=$group\n";
+	}
+	printf "context=$context\n";
+	printf "immediate=$immediate\n" if defined $immediate;
+	printf "channel => %d\n", $num;
+	# Reset following values to default
+	printf "callerid=\n";
+	printf "mailbox=\n" unless $type eq 'FXO';
+	if(defined $group) {
+		printf "group=\n";
+	}
+	printf "context=default\n";
+	printf "immediate=no\n" if defined $immediate;
+	print "\n";
+}
+
+sub generate($) {
+	my $self = shift || die;
+	my $file = $self->{FILE};
+	my $gconfig = $self->{GCONFIG};
+	my $genopts = $self->{GENOPTS};
+	#$gconfig->dump;
+	my @spans = @_;
+	warn "Empty configuration -- no spans\n" unless @spans;
+	rename "$file", "$file.bak"
+		or $! == 2	# ENOENT (No dependency on Errno.pm)
+		or die "Failed to backup old config: $!\n";
+	print "Generating $file\n" if $genopts->{verbose};
+	open(F, ">$file") || die "$0: Failed to open $file: $!\n";
+	my $old = select F;
+	printf "; Autogenerated by $0 on %s\n", scalar(localtime);
+	print  "; If you edit this file and execute $0 again,\n";
+	print  "; your manual changes will be LOST.\n";
+	print <<"HEAD";
+; Dahdi Channels Configurations (chan_dahdi.conf)
+;
+; This is not intended to be a complete chan_dahdi.conf. Rather, it is intended
+; to be #include-d by /etc/chan_dahdi.conf that will include the global settings
+;
+
+HEAD
+	foreach my $span (@spans) {
+		printf "; Span %d: %s %s\n", $span->num, $span->name, $span->description;
+		if($span->is_digital()) {
+			$self->gen_digital($span);
+		} else {
+			foreach my $chan ($span->chans()) {
+				if(is_true($genopts->{'freepbx'}) || is_true($gconfig->{'freepbx'})) {
+					# Freepbx has its own idea about channels
+					my $type = $chan->type;
+					if($type eq 'FXS' || $type eq 'OUT' || $type eq 'IN') {
+						printf "; Skip channel=%s($type) -- freepbx option.\n",
+							$chan->num;
+						next;
+					}
+				}
+				$self->gen_channel($chan);
+			}
+		}
+		print "\n";
+	}
+	close F;
+	select $old;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+chandahdi - Generate configuration for chan_dahdi channels.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen::Chandahdi;
+
+ my $cfg = new Dahdi::Config::Gen::Chandahdi(\%global_config, \%genopts);
+ $cfg->generate(@span_list);
+
+=head1 DESCRIPTION
+
+Generate the F</etc/asterisk/dahdi-channels.conf>
+This is used as a configuration for asterisk(1).
+It should be included in the main F</etc/asterisk/chan_dahdi.conf>.
+
+Its location may be overriden via the environment variable 
+C<CHAN_DAHDI_CHANNELS_FILE>.
+
+=head1 OPTIONS
+
+=over 4
+
+=item freepbx
+
+With this option we do not generate channel definitions for FXS, Input and
+Output ports. This is done because these channel definitions need to be
+generated and inserted into I<freepbx> database anyway.
+
+=back
+
+The I<freepbx> option may be activated also by adding a C<freepbx yes> line
+to the C<genconf_parameters> file.

Added: trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,168 @@
+package Dahdi::Config::Gen::Destar;
+#
+# This file was written by Alejandro Rios <alerios at debian.org>
+# Based on Dahdi's perl_modules by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+
+use strict;
+
+use Dahdi::Config::Gen qw(is_true);
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $gconfig = shift || die;
+	my $genopts = shift || die;
+	my $file = $ENV{DESTAR_FILE} || "/etc/asterisk/destar_channels.py";
+	my $self = {
+			FILE	=> $file,
+			GCONFIG	=> $gconfig,
+			GENOPTS	=> $genopts,
+		};
+	bless $self, $pack;
+	return $self;
+}
+
+# Since chan_dahdi definitions "leak" to the next ones, we try
+# To reset some important definitions to their chan_dahdi defaults.
+my %destar_defaults = (
+        group    => '"1"',
+);
+
+sub reset_destar_values {
+	foreach my $arg (@_) {
+		if (exists $destar_defaults{$arg}) {
+			print "\t$arg = $destar_defaults{$arg},\n";
+		} else {
+			print "\t$arg = None,\n";
+		}
+	}
+}
+
+sub gen_openr2($$$) {
+	printf "#coming soon\n";
+}
+
+sub gen_cas($$$) {
+	printf "#coming soon\n";
+}
+
+sub gen_digital($$$) {
+	my $self = shift || die;
+	my $gconfig = shift || die;
+	my $span = shift || die;
+	my $num = $span->num() || die;
+	die "Span #$num is analog" unless $span->is_digital();
+	if($span->is_pri && $gconfig->{'pri_connection_type'} eq 'R2') {
+		printf "; Skipped: $gconfig->{'pri_connection_type'}\n\n";
+		return;
+	}
+	my $type = $span->type() || die "$0: Span #$num -- unkown type\n";
+	my $termtype = $span->termtype() || die "$0: Span #$num -- unkown termtype [NT/TE]\n";
+	my $group = $gconfig->{'group'}{"$type"};
+	my $context = $gconfig->{'context'}{"$type"};
+	my @to_reset = qw/context group/;
+
+	die "$0: missing default group (termtype=$termtype)\n" unless defined($group);
+	die "$0: missing default context\n" unless $context;
+
+	my $sig = $span->signalling || die "missing signalling info for span #$num type $type";
+	grep($gconfig->{'bri_sig_style'} eq $_, 'bri', 'bri_ptmp', 'pri') or die "unknown signalling style for BRI";
+
+	if($span->is_bri() and $gconfig->{'bri_sig_style'} eq 'bri_ptmp') {
+		$sig .= '_ptmp';
+	}
+
+	printf "CfgTrunkDAHDIPRI(\n";
+	printf "\tname = \"Span_%d\",\n", $span->num, $span->name, $span->description;
+	printf "\tdescription = \"%s\",\n", $span->name;
+	if ($span->is_bri() && $termtype eq 'NT' && is_true($gconfig->{'brint_overlap'})) {
+		print "\toverlapdial = True\n";
+		push(@to_reset, qw/overlapdial/);
+	}
+
+	printf "\tswitchtype = \"%s\",\n", $span->switchtype;
+	printf "\tsignalling = \"%s\",\n", $sig;
+	printf "\tchannels = \"%s\",\n", Dahdi::Config::Gen::bchan_range($span);
+	reset_destar_values(@to_reset);
+	printf "\t)\n";
+}
+
+sub gen_channel($$) {
+	printf "#coming soon\n";
+}
+
+sub generate($) {
+	my $self = shift || die;
+	my $file = $self->{FILE};
+	my $gconfig = $self->{GCONFIG};
+	my $genopts = $self->{GENOPTS};
+	#$gconfig->dump;
+	my @spans = @_;
+	warn "Empty configuration -- no spans\n" unless @spans;
+	rename "$file", "$file.bak"
+		or $! == 2	# ENOENT (No dependency on Errno.pm)
+		or die "Failed to backup old config: $!\n";
+	print "Generating $file\n" if $genopts->{verbose};
+	open(F, ">$file") || die "$0: Failed to open $file: $!\n";
+	my $old = select F;
+	printf "# Autogenerated by $0 on %s\n", scalar(localtime);
+        print  "# If you edit this file and execute $0 again,\n";
+        print  "# your manual changes will be LOST.\n";
+        print <<"HEAD";
+# Destar's Dahdi Channels Configurations (destar_channels.py)
+#
+# This is not intended to be a complete destar_cfg.py. Rather, it is intended
+# to be loaded at runtime by destar to provide autodetection for Dahdi trunks.
+#
+
+HEAD
+	foreach my $span (@spans) {
+		printf "# Span %d: %s %s\n", $span->num, $span->name, $span->description;
+		if($span->is_digital) {
+			if($span->is_pri) {
+				if($gconfig->{'pri_connection_type'} eq 'R2') {
+					$self->gen_openr2($gconfig, $span);
+				} elsif($gconfig->{'pri_connection_type'} eq 'CAS') {
+					$self->gen_cas($gconfig, $span);
+				} else {
+					$self->gen_digital($gconfig, $span);
+				}
+			} elsif($span->is_bri) {
+				$self->gen_digital($gconfig, $span);
+			}
+		} else {
+			foreach my $chan ($span->chans()) {
+				$self->gen_channel($chan);
+			}
+		}
+		print "\n";
+	}
+	close F;
+	select $old;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+destar - Generate DeStar's configuration for chan_dahdi channels.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen::Destar;
+
+ my $cfg = new Dahdi::Config::Gen::Destar(\%global_config, \%genopts);
+ $cfg->generate(@span_list);
+
+=head1 DESCRIPTION
+
+Generate the F</etc/asterisk/destar_channels.py>
+This is used as a configuration for destar(1) at runtime.
+
+Its location may be overriden via the environment variable 
+C<DESTAR_FILE>.

Added: trunk/dahdi-gen/Dahdi/Config/Gen/Modules.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/Modules.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/Modules.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,62 @@
+package Dahdi::Config::Gen::Modules;
+use strict;
+
+use Dahdi::Config::Gen qw(is_true);
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $gconfig = shift || die;
+	my $genopts = shift || die;
+	my $file = $ENV{DAHDI_MODULES_FILE} || "/etc/dahdi/modules";
+	my $self = {
+			FILE	=> $file,
+			GCONFIG	=> $gconfig,
+			GENOPTS	=> $genopts,
+		};
+	bless $self, $pack;
+	return $self;
+}
+
+sub generate($$$) {
+	my $self = shift || die;
+	my $file = $self->{FILE};
+	my $gconfig = $self->{GCONFIG};
+	my $genopts = $self->{GENOPTS};
+	rename "$file", "$file.bak"
+		or $! == 2	# ENOENT (No dependency on Errno.pm)
+		or die "Failed to backup old config: $!\n";
+	#$gconfig->dump;
+	print "Generating $file\n" if $genopts->{verbose};
+	open(F, ">$file") || die "$0: Failed to open $file: $!\n";
+	my $old = select F;
+	printf "# Autogenerated by $0 (%s) on %s\n", __PACKAGE__, scalar(localtime);
+	print  "# If you edit this file and execute $0 again,\n";
+	print  "# your manual changes will be LOST.\n";
+	my @drivers = Dahdi::Hardware->drivers;
+	print join("\n", @drivers),"\n";
+	close F;
+	select $old;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+modules - Generate list of dahdi drivers to load at startup
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen::Dahdi;
+
+ my $cfg = new Dahdi::Config::Gen::Modules(\%global_config, \%genopts);
+ $cfg->generate(@span_list);
+
+=head1 DESCRIPTION
+
+Generate the F</etc/dahdi/modules>. This is a list of modules, one per
+line. This list is normally used by F</etc/init.d/dahdi>.
+
+Its location may be overriden via the environment variable
+F<DAHDI_MODULES_FILE>.

Added: trunk/dahdi-gen/Dahdi/Config/Gen/System.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/System.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/System.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,194 @@
+package Dahdi::Config::Gen::System;
+use strict;
+
+use Dahdi::Config::Gen qw(is_true);
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $gconfig = shift || die;
+	my $genopts = shift || die;
+	my $file = $ENV{DAHDI_CONF_FILE} || "/etc/dahdi/system.conf";
+	my $self = {
+			FILE	=> $file,
+			GCONFIG	=> $gconfig,
+			GENOPTS	=> $genopts,
+		};
+	bless $self, $pack;
+	return $self;
+}
+
+my $bri_te_last_timing = 1;
+
+sub print_echo_can($$) {
+	my $gconfig = shift || die;
+	my $chans = shift || die; # channel or range of channels.
+	my $echo_can = $gconfig->{'echo_can'};
+	return if !defined($echo_can) || $echo_can eq 'none';
+
+	print "echocanceller=$echo_can,$chans\n";
+}
+
+sub gen_digital($$) {
+	my $gconfig = shift || die;
+	my $span = shift || die;
+	my $num = $span->num() || die;
+	die "Span #$num is analog" unless $span->is_digital();
+	my $termtype = $span->termtype() || die "$0: Span #$num -- unkown termtype [NT/TE]\n";
+	my $timing;
+	my $lbo = 0;
+	my $framing = $span->framing() || die "$0: No framing information for span #$num\n";
+	my $coding =  $span->coding() || die "$0: No coding information for span #$num\n";
+	my $span_crc4 = $span->crc4();
+	$span_crc4 = (defined $span_crc4) ? ",$span_crc4" : '';
+	my $span_yellow = $span->yellow();
+	$span_yellow = (defined $span_yellow) ? ",$span_yellow" : '';
+	# "MFC/R2 does not normally use CRC4"
+	# FIXME: a finer way to override:
+	if ($gconfig->{'pri_connection_type'} eq 'R2') { 
+		$span_crc4 = '';
+		$framing = 'cas';
+	}
+	$timing = ($termtype eq 'NT') ? 0 : $bri_te_last_timing++;
+	printf "span=%d,%d,%d,%s,%s%s%s\n",
+			$num,
+			$timing,
+			$lbo,
+			$framing,
+			$coding,
+			$span_crc4,
+			$span_yellow;
+	printf "# termtype: %s\n", lc($termtype);
+	my $dchan_type;
+	if ($span->is_bri()) {
+		my $use_bristuff = 0;
+		my $cfg_hardhdlc = $gconfig->{'bri_hardhdlc'};
+		my $xpd = $span->xpd();
+		if(!defined($cfg_hardhdlc) || $cfg_hardhdlc =~ /AUTO/i) {
+			# Autodetect
+			if(defined($xpd)) {
+				# Bristuff?
+				if(defined($xpd->dchan_hardhdlc) && !is_true($xpd->dchan_hardhdlc)) {
+					$use_bristuff = 1;
+				}
+			}
+		} elsif(!is_true($cfg_hardhdlc)) {
+			$use_bristuff = 1;
+		}
+		if($use_bristuff) {
+			$dchan_type = 'dchan';
+		} else {
+			$dchan_type = 'hardhdlc';
+		}
+		printf "bchan=%s\n", Dahdi::Config::Gen::bchan_range($span);
+		my $dchan = $span->dchan();
+		printf "$dchan_type=%d\n", $dchan->num();
+	} elsif($span->is_pri()) {
+		if ($gconfig->{'pri_connection_type'} eq 'PRI') {
+			printf "bchan=%s\n", Dahdi::Config::Gen::bchan_range($span);
+			my $dchan = $span->dchan();
+			printf "dchan=%d\n", $dchan->num();
+		} elsif ($gconfig->{'pri_connection_type'} eq 'R2' ) {
+			my $idle_bits = $gconfig->{'r2_idle_bits'};
+			printf "cas=%s:$idle_bits\n", Dahdi::Config::Gen::bchan_range($span);
+			printf "dchan=%d\n", $span->dchan()->num();
+		}
+	} else {
+		die "Digital span $num is not BRI, nor PRI?";
+	}
+	print_echo_can($gconfig, Dahdi::Config::Gen::bchan_range($span));
+}
+
+sub gen_signalling($$) {
+	my $gconfig = shift || die;
+	my $chan = shift || die;
+	my $type = $chan->type;
+	my $num = $chan->num;
+
+	die "channel $num type $type is not an analog channel\n" if $chan->span->is_digital();
+	if($type eq 'EMPTY') {
+		printf "# channel %d, %s, no module.\n", $num, $chan->fqn;
+		return;
+	}
+	my $signalling = $gconfig->{'dahdi_signalling'};
+	my $sig = $signalling->{$type} || die "unknown default dahdi signalling for chan $num type $type";
+	if ($type eq 'IN') {
+		printf "# astbanktype: input\n";
+	} elsif ($type eq 'OUT') {
+		printf "# astbanktype: output\n";
+	}
+	printf "$sig=$num\n";
+	print_echo_can($gconfig, $num);
+}
+
+sub generate($$$) {
+	my $self = shift || die;
+	my $file = $self->{FILE};
+	my $gconfig = $self->{GCONFIG};
+	my $genopts = $self->{GENOPTS};
+	my @spans = @_;
+	warn "Empty configuration -- no spans\n" unless @spans;
+	rename "$file", "$file.bak"
+		or $! == 2	# ENOENT (No dependency on Errno.pm)
+		or die "Failed to backup old config: $!\n";
+	#$gconfig->dump;
+	print "Generating $file\n" if $genopts->{verbose};
+	open(F, ">$file") || die "$0: Failed to open $file: $!\n";
+	my $old = select F;
+	printf "# Autogenerated by $0 on %s\n", scalar(localtime);
+	print  "# If you edit this file and execute $0 again,\n";
+	print  "# your manual changes will be LOST.\n";
+	print <<"HEAD";
+# Dahdi Configuration File
+#
+# This file is parsed by the Dahdi Configurator, dahdi_cfg
+#
+HEAD
+	foreach my $span (@spans) {
+		printf "# Span %d: %s %s\n", $span->num, $span->name, $span->description;
+		if($span->is_digital()) {
+			gen_digital($gconfig, $span);
+		} else {
+			foreach my $chan ($span->chans()) {
+				if(1 || !defined $chan->type) {
+					my $type = $chan->probe_type;
+					my $num = $chan->num;
+					die "Failed probing type for channel $num"
+						unless defined $type;
+					$chan->type($type);
+				}
+				gen_signalling($gconfig, $chan);
+			}
+		}
+		print "\n";
+	}
+	print <<"TAIL";
+# Global data
+
+loadzone	= $gconfig->{'loadzone'}
+defaultzone	= $gconfig->{'defaultzone'}
+TAIL
+	close F;
+	select $old;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+dahdi - Generate configuration for dahdi drivers.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen::Dahdi;
+
+ my $cfg = new Dahdi::Config::Gen::Dahdi(\%global_config, \%genopts);
+ $cfg->generate(@span_list);
+
+=head1 DESCRIPTION
+
+Generate the F</etc/dahdi/system.conf>.
+This is the configuration for dahdi_cfg(1).
+
+Its location may be overriden via the environment variable F<DAHDI_CONF_FILE>.

Added: trunk/dahdi-gen/Dahdi/Config/Gen/Unicall.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/Unicall.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/Unicall.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,72 @@
+package Dahdi::Config::Gen::Unicall;
+use strict;
+
+use Dahdi::Config::Gen qw(is_true);
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $gconfig = shift || die;
+	my $genopts = shift || die;
+	my $file = $ENV{UNICALL_CHANNELS_FILE} || "/etc/asterisk/unicall-channels.conf";
+	my $self = {
+			FILE	=> $file,
+			GCONFIG	=> $gconfig,
+			GENOPTS	=> $genopts,
+		};
+	bless $self, $pack;
+	return $self;
+}
+
+sub generate($) {
+	my $self = shift || die;
+	my $file = $self->{FILE};
+	my $gconfig = $self->{GCONFIG};
+	my $genopts = $self->{GENOPTS};
+	#$gconfig->dump;
+	my @spans = @_;
+	warn "Empty configuration -- no spans\n" unless @spans;
+	die "Only for R2" unless $gconfig->{'pri_connection_type'} eq 'R2';
+	rename "$file", "$file.bak"
+		or $! == 2	# ENOENT (No dependency on Errno.pm)
+		or die "Failed to backup old config: $!\n";
+	print "Generating $file\n" if $genopts->{verbose};
+	open(F, ">$file") || die "$0: Failed to open $file: $!\n";
+	my $old = select F;
+	printf "; Autogenerated by $0 on %s\n", scalar(localtime);
+	print  "; If you edit this file and execute $0 again,\n";
+	print  "; your manual changes will be LOST.\n";
+	print  "; This file should be #included in unicall.conf\n\n";
+	foreach my $span (@spans) {
+		next unless $span->is_digital();
+		printf "; Span %d: %s %s\n", $span->num, $span->name, $span->description;
+		my $idle_bits = $gconfig->{'r2_idle_bits'}; 
+		printf "protocolend=%s\n", ($span->termtype() eq 'TE') ? 'cpe' : 'co';
+		printf "channel=%s\n", Dahdi::Config::Gen::bchan_range($span);
+		print "\n";
+	}
+	close F;
+	select $old;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+unicall - Generate configuration for unicall channels.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen::Unicall;
+
+ my $cfg = new Dahdi::Config::Gen::Unicall(\%global_config, \%genopts);
+ $cfg->generate(@span_list);
+
+=head1 DESCRIPTION
+
+Generate the F</etc/asterisk/unicall-channels.conf> to be included in 
+F</etc/asterisk/unicall.conf>
+
+Its location may be overriden via the environment variable 
+C<UNICALL_CHANNELS_FILE>.

Added: trunk/dahdi-gen/Dahdi/Config/Gen/Users.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/Users.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/Users.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,227 @@
+package Dahdi::Config::Gen::Users;
+use strict;
+
+use File::Basename;
+use Dahdi::Config::Gen qw(is_true);
+
+# Generate a complete users.conf for the asterisk-gui
+# As the asterisk-gui provides no command-line interface of its own and
+# no decent support of #include, we have no choice but to nuke users.conf
+# if we're to provide a working system
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $gconfig = shift || die;
+	my $genopts = shift || die;
+	my $file = $ENV{USERS_FILE} || "/etc/asterisk/users.conf";
+	my $self = {
+			FILE	=> $file,
+			GCONFIG	=> $gconfig,
+			GENOPTS	=> $genopts,
+		};
+	bless $self, $pack;
+	return $self;
+}
+
+# A single analog trunk for all the FXO channels
+sub gen_analog_trunk {
+	my @fxo_ports = @_;
+	return unless (@fxo_ports); # no ports
+
+	my $ports = join(',', @fxo_ports);
+
+	print << "EOF"
+[trunk_1]
+trunkname = analog
+hasexten = no
+hasiax = no
+hassip = no
+hasregisteriax = no
+hasregistersip = no
+trunkstyle = analog
+dahdichan = $ports
+
+EOF
+}
+
+# A digital trunk for a single span.
+# FIXME: how do I create the DID context?
+sub gen_digital_trunk($) {
+	my $span = shift;
+	my $num = $span->num;
+	my $sig = $span->signalling;
+	my $type = $span->type;
+	my $bchan_range = Dahdi::Config::Gen::bchan_range($span);
+
+	print << "EOF";
+[span_$num]
+group = $num
+hasexten = no
+signalling = $sig
+trunkname = Span $num $type
+trunkstyle = digital  ; GUI metadata
+hassip = no
+hasiax = no
+context = DID_span_$num
+dahdichan = $bchan_range
+
+EOF
+}
+
+my $ExtenNum;
+
+# A single user for a FXS channel
+sub gen_channel($$) {
+	my $self = shift || die;
+	my $chan = shift || die;
+	my $gconfig = $self->{GCONFIG};
+	my $type = $chan->type;
+	my $num = $chan->num;
+	die "channel $num type $type is not an analog channel\n" if $chan->span->is_digital();
+	my $exten = $ExtenNum++;
+	my $sig = $gconfig->{'chan_dahdi_signalling'}{$type};
+	my $full_name = "$type $num";
+
+	die "missing default_chan_dahdi_signalling for chan #$num type $type" unless $sig;
+	print << "EOF";
+[$exten]
+context = DLPN_DialPlan1
+callwaiting = yes
+fullname = $full_name
+cid_number = $exten
+hasagent = no
+hasdirectory = no
+hasiax = no
+hasmanager = no
+hassip = no
+hasvoicemail = yes
+mailbox = $exten
+threewaycalling = yes
+vmsecret = $exten
+signalling = $sig
+dahdichan = $num
+registeriax = no
+registersip = no
+canreinvite = no
+
+EOF
+}
+
+sub generate($) {
+	my $self = shift || die;
+	my $file = $self->{FILE};
+	my $gconfig = $self->{GCONFIG};
+	my $genopts = $self->{GENOPTS};
+	#$gconfig->dump;
+	my @spans = @_;
+	warn "Empty configuration -- no spans\n" unless @spans;
+	rename "$file", "$file.bak"
+		or $! == 2	# ENOENT (No dependency on Errno.pm)
+		or die "Failed to backup old config: $!\n";
+	print "Generating $file\n" if $genopts->{verbose};
+	open(F, ">$file") || die "$0: Failed to open $file: $!\n";
+	my $old = select F;
+	print <<"HEAD";
+;!
+;! Automatically generated configuration file
+;! Filename: @{[basename($file)]} ($file)
+;! Generator: $0
+;! Creation Date: @{[scalar(localtime)]}
+;! If you edit this file and execute $0 again,
+;! your manual changes will be LOST.
+;!
+[general]
+;
+; Starting point of allocation of extensions
+;
+userbase = @{[$gconfig->{'base_exten'}+1]}
+;
+; Create voicemail mailbox and use use macro-stdexten
+;
+hasvoicemail = yes
+;
+; Set voicemail mailbox @{[$gconfig->{'base_exten'}+1]} password to 1234
+;
+vmsecret = 1234
+;
+; Create SIP Peer
+;
+hassip = no
+;
+; Create IAX friend
+;
+hasiax = no
+;
+; Create Agent friend
+;
+hasagent = no
+;
+; Create H.323 friend
+;
+;hash323 = yes
+;
+; Create manager entry
+;
+hasmanager = no
+;
+; Remaining options are not specific to users.conf entries but are general.
+;
+callwaiting = yes
+threewaycalling = yes
+callwaitingcallerid = yes
+transfer = yes
+canpark = yes
+cancallforward = yes
+callreturn = yes
+callgroup = 1
+pickupgroup = 1
+localextenlength = @{[length($gconfig->{'base_exten'})]}
+
+
+HEAD
+	my @fxo_ports = ();
+	$ExtenNum = $self->{GCONFIG}->{'base_exten'};
+	foreach my $span (@spans) {
+		printf "; Span %d: %s %s\n", $span->num, $span->name, $span->description;
+		if ($span->type =~ /^(BRI_(NT|TE)|E1|T1)$/) {
+			gen_digital_trunk($span);
+			next;
+		}
+		foreach my $chan ($span->chans()) {
+			if (grep { $_ eq $span->type} ( 'FXS', 'IN', 'OUT' )) {
+				$self->gen_channel($chan);
+			} elsif ($chan->type eq 'FXO') {
+				# TODO: "$first_chan-$last_chan"
+				push @fxo_ports,($chan->num);
+			}
+		}
+		print "\n";
+	}
+	gen_analog_trunk(@fxo_ports);
+	close F;
+	select $old;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+users - Generate configuration for users.conf.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen::Users;
+
+ my $cfg = new Dahdi::Config::Gen::Users(\%global_config, \%genopts);
+ $cfg->generate(@span_list);
+
+=head1 DESCRIPTION
+
+Generate the F</etc/asterisk/users.conf> which is used by asterisk(1) 
+and AsteriskGUI. This will replace your entire configuration including
+any SIP/IAX users and trunks you may have set. Thus it's probably only
+appropriate for an initial setup.
+
+Its location may be overriden via the environment variable F<USERS_FILE>.

Added: trunk/dahdi-gen/Dahdi/Config/Gen/Xpporder.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/Xpporder.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/Xpporder.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,142 @@
+package Dahdi::Config::Gen::Xpporder;
+use strict;
+
+use Dahdi::Config::Gen qw(is_true);
+use Dahdi::Xpp;
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $gconfig = shift || die;
+	my $genopts = shift || die;
+	my $file = $ENV{XPPORDER_CONF} || "/etc/dahdi/xpp_order";
+	my $self = {
+			FILE	=> $file,
+			GCONFIG	=> $gconfig,
+			GENOPTS	=> $genopts,
+		};
+	bless $self, $pack;
+	return $self;
+}
+
+#
+# Returns list of xbuses sorted by the span numbers assigned
+# to their XPD's. Also checks that each XBUS span numbers are sequential.
+sub get_sorted_xbuses(@) {
+	my @spans = @_;	# Verify our spans
+	my @xbuses = Dahdi::Xpp::xbuses;
+	my %xbus_of_span;
+	my %xbus_beginning;
+	my %seen_spans;
+	my @sorted_xbuses;
+	foreach my $xbus (@xbuses) {
+		my $last_spanno;
+		foreach my $xpd ($xbus->xpds) {
+			my $spanno = $xpd->spanno;
+			if(!$spanno) {
+				printf STDERR "%s: Is not registered. Skipping.\n", $xpd->fqn;
+				next;
+			}
+			$seen_spans{$spanno}++;
+			if($xbus_of_span{$spanno}) {
+				printf STDERR "%s: Span %d already seen on %s\n",
+					$xpd->fqn, $spanno, $xbus_of_span{$spanno}->name;
+				die;
+			}
+			$xbus_of_span{$spanno} = $xbus;
+			# Check XPD's sequential numbering
+			if(defined $last_spanno) {
+				if($last_spanno + 1 != $spanno) {
+					printf STDERR "%s: Bad span numbers (%d, %d)\n",
+						$xpd->fqn, $last_spanno, $spanno;
+					die;
+				}
+			} else {
+				$xbus_beginning{$xbus} = $spanno;
+			}
+			$last_spanno = $spanno;
+		}
+	}
+	foreach my $span (@spans) {
+		my $spanno = $span->num;
+		if(!defined($seen_spans{$spanno})) {
+			warn "Span $spanno: Ignored: Does not belong to any XPD\n";
+		}
+	}
+	@sorted_xbuses = sort { $xbus_beginning{$a} <=> $xbus_beginning{$b} } @xbuses;
+	return @sorted_xbuses;
+}
+
+sub generate($$$) {
+	my $self = shift || die;
+	my $file = $self->{FILE};
+	my $gconfig = $self->{GCONFIG};
+	my $genopts = $self->{GENOPTS};
+	my @spans = @_;		# Verify it's all our spans
+	my @xbuses = get_sorted_xbuses(@spans);
+	warn "Empty configuration -- no xbuses\n" unless @xbuses;
+	rename "$file", "$file.bak"
+		or $! == 2	# ENOENT (No dependency on Errno.pm)
+		or die "Failed to backup old config: $!\n";
+	#$gconfig->dump;
+	print "Generating $file\n" if $genopts->{verbose};
+	open(F, ">$file") || die "$0: Failed to open $file: $!\n";
+	my $old = select F;
+	printf "# Autogenerated by $0 on %s\n", scalar(localtime);
+	print  "# If you edit this file and execute $0 again,\n";
+	print  "# your manual changes will be LOST.\n";
+	print <<'HEAD';
+#
+# This is an optional configuration file for ordering
+# Dahdi registration.
+#
+# It is read from /etc/dahdi/xpp_order. This location
+# may be overridden via the environment variable XPPORDER_CONF
+#
+# Lines may contain:
+#   - The Astribank label (verbatim)
+#   - The Astribank connector string (prefixed with @)
+# Ordering number of each listed Astribank is determined
+# by its position in this file.
+# Astribanks not listed in this file, get an ordering
+# number of 99 (last).
+#
+# Astribanks with same ordering number are sorted by their
+# connectors (to preserve legacy behavior).
+#
+# Examples:
+#usb:1234
+#@usb-0000:06:02.2-2
+HEAD
+	foreach my $xbus (@xbuses) {
+		my $label = $xbus->label;
+		my $connector = $xbus->connector;
+		my $name = $xbus->name;
+		printf "%s\t# %s (%s)\n", $label, $connector, $name;
+	}
+	close F;
+	select $old;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+Xpporder - Generate Astribank ordering information for dahdi_registration.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen::Xpporder;
+
+ my $cfg = new Dahdi::Config::Gen::Xpporder(\%global_config, \%genopts);
+ $cfg->generate;
+
+=head1 DESCRIPTION
+
+Generate the F</etc/dahdi/xpp_order>.
+This is the configuration for dahdi_registration(1).
+The order is determined according to current Dahdi registration
+order.
+
+Its location may be overriden via the environment variable F<XPPORDER_CONF>.

Added: trunk/dahdi-gen/Dahdi/Config/Gen.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Gen.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,213 @@
+package Dahdi::Config::Gen;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2009, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Gen.pm 6272 2009-03-29 18:53:02Z tzafrir $
+#
+
+=head1 NAME
+
+Dahdi::Config::Gen -- Wrapper class for configuration generators.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Gen qw(is_true);
+ my $params = Dahdi::Config::Params->new('the-config-file');
+ my $gconfig = Dahdi::Config::Gen->new($params);
+ my $num = $gconfig->{'base_exten'};
+ my $overlap = is_true($gconfig->{'brint_overlap'});
+ $gconfig->dump;	# For debugging
+ $gconfig->run_generator('system', {}, @spans);
+
+=head1 DESCRIPTION
+
+The constructor must be given an C<Dahdi::Config::Params> object.
+The returned object contains all data required for generation in the
+form of a hash.
+
+The constructor maps the C<item()>s from the parameter object into semantic
+configuration keys.  E.g: the C<lc_country> item is mapped to C<loadzone> and
+C<defaultzone> keys.
+
+The actual generation is done by delegation to one of the generators.
+This is done via the C<run_generator()> method which receive the
+generator name, a generator specific options hash and a list of
+span objects (from C<Dahdi::Span>) for which to generate configuration.
+
+This module contains few helper functions. E.g: C<is_true()>, C<bchan_range()>.
+
+=cut
+
+require Exporter;
+ at ISA = qw(Exporter);
+
+ at EXPORT_OK = qw(is_true);
+
+use strict;
+
+# Parse values as true/false 
+sub is_true($) {
+	my $val = shift;
+	return undef unless defined $val;
+	return $val =~ /^(1|y|yes)$/i;
+}
+
+# Generate channel range strings from span objects
+# E.g: "63-77,79-93"
+sub bchan_range($) {
+	my $span = shift || die;
+	my $first_chan = ($span->chans())[0];
+	my $first_num = $first_chan->num();
+	my $range_start = $first_num;
+	my @range;
+	my $prev = undef;
+
+	die unless $span->is_digital();
+	foreach my $c (@{$span->bchan_list()}) {
+		my $curr = $c + $first_num;
+		if(!defined($prev)) {
+			$prev = $curr;
+		} elsif($curr != $prev + 1) {
+			push(@range, sprintf("%d-%d", $range_start, $prev));
+			$range_start = $curr;
+		}
+		$prev = $curr;
+	}
+	if($prev >= $first_num) {
+		push(@range, sprintf("%d-%d", $range_start, $prev));
+	}
+	return join(',', @range);
+}
+
+sub new($) {
+	my $pack = shift || die "$0: Missing package argument";
+	my $p = shift || die "$0: Missing parameters argument";
+
+	# Set defaults
+	my $fxs_default_start = $p->item('fxs_default_start');
+	my $fxo_default_start = $p->item('fxo_default_start');
+
+	my %default_context = (
+		FXO	=> $p->item('context_lines'),
+		FXS	=> $p->item('context_phones'),
+		IN	=> $p->item('context_input'),
+		OUT	=> $p->item('context_output'),
+		BRI_TE	=> $p->item('context_lines'),
+		BRI_NT	=> $p->item('context_lines'),
+		E1_TE	=> $p->item('context_lines'),
+		T1_TE	=> $p->item('context_lines'),
+		J1_TE	=> $p->item('context_lines'),
+		E1_NT	=> $p->item('context_lines'),
+		T1_NT	=> $p->item('context_lines'),
+		J1_NT	=> $p->item('context_lines'),
+		);
+	my %default_group = (
+		FXO	=> $p->item('group_lines'),
+		FXS	=> $p->item('group_phones'),
+		IN	=> '',
+		OUT	=> '',
+		BRI_TE	=> $p->item('group_lines'),
+		BRI_NT	=> $p->item('group_lines'),
+		E1_TE	=> $p->item('group_lines'),
+		T1_TE	=> $p->item('group_lines'),
+		J1_TE	=> $p->item('group_lines'),
+		E1_NT	=> $p->item('group_lines'),
+		T1_NT	=> $p->item('group_lines'),
+		J1_NT	=> $p->item('group_lines'),
+		);
+	my %default_dahdi_signalling = (
+		FXO	=> "fxs$fxo_default_start",
+		FXS	=> "fxo$fxs_default_start",
+		IN	=> "fxo$fxs_default_start",
+		OUT	=> "fxo$fxs_default_start",
+		);
+	my %default_chan_dahdi_signalling = (
+		FXO	=> "fxs_$fxo_default_start",
+		FXS	=> "fxo_$fxs_default_start",
+		IN	=> "fxo_$fxs_default_start",
+		OUT	=> "fxo_$fxs_default_start",
+		);
+
+	# First complex mapping
+	my $gconfig = {
+			PARAMETERS	=> $p,
+			'loadzone'	=> $p->item('lc_country'),
+			'defaultzone'	=> $p->item('lc_country'),
+			'context'	=> \%default_context,
+			'group'		=> \%default_group,
+			'dahdi_signalling'	=> \%default_dahdi_signalling,
+			'chan_dahdi_signalling'	=> \%default_chan_dahdi_signalling,
+		};
+	# Now add trivial mappings
+	my @trivial = qw(
+		base_exten
+		freepbx
+		fxs_immediate
+		bri_hardhdlc
+		bri_sig_style
+		r2_idle_bits
+		echo_can
+		brint_overlap
+		pri_termtype
+		pri_connection_type
+		);
+	foreach my $k (@trivial) {
+		$gconfig->{$k} = $p->item($k);
+	}
+	bless $gconfig,$pack;
+
+	return $gconfig;
+}
+
+sub run_generator($$@) {
+	my $gconfig = shift || die;
+	my $name = shift || die "$0: Missing generator name argument";
+	my $genopts = shift || die "$0: Missing genopts argument";
+	ref($genopts) eq 'HASH' or die "$0: Bad genopts argument";
+	my @spans = @_;
+
+	my $module = "Dahdi::Config::Gen::$name";
+	#print STDERR "DEBUG: $module\n";
+	eval "use $module";
+	if($@) {
+		die "Failed to load configuration generator for '$name'\n";
+	}
+	my $cfg = $module->new($gconfig, $genopts);
+	$cfg->generate(@spans);
+}
+
+sub dump($) {
+	my $self = shift || die;
+	printf STDERR "%s dump:\n", ref $self;
+	my $width = 30;
+	foreach my $k (sort keys %$self) {
+		my $val = $self->{$k};
+		my $ref = ref $val;
+		#print STDERR "DEBUG: '$k', '$ref', '$val'\n";
+		if($ref eq '') {
+			printf STDERR "%-${width}s %s\n", $k, $val;
+		} elsif($ref eq 'SCALAR') {
+			printf STDERR "%-${width}s %s\n", $k, ${$val};
+		} elsif($ref eq 'ARRAY') {
+			#printf STDERR "%s:\n", $k;
+			my $i = 0;
+			foreach my $v (@{$val}) {
+				printf STDERR "%-${width}s %s\n", "$k\->[$i]", $v;
+				$i++;
+			}
+		} elsif($ref eq 'HASH') {
+			#printf STDERR "%s:\n", $k;
+			foreach my $k1 (keys %{$val}) {
+				printf STDERR "%-${width}s %s\n", "$k\->\{$k1\}", ${$val}{$k1};
+			}
+		} else {
+			printf STDERR "%-${width}s (-> %s)\n", $k, $ref;
+		}
+	}
+}
+
+
+1;

Added: trunk/dahdi-gen/Dahdi/Config/Params.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Params.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Config/Params.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,149 @@
+package Dahdi::Config::Params;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2009, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Params.pm 6647 2009-05-19 16:46:06Z tzafrir $
+#
+use strict;
+
+=head1 NAME
+
+Dahdi::Config::Params -- Object oriented representation of F<genconf_parameters> file.
+
+=head1 SYNOPSIS
+
+ use Dahdi::Config::Params;
+ my $params = Dahdi::Config::Params->new('the-config-file');
+ print $params->item{'some-key'};
+ $params->dump;	# For debugging
+
+=head1 DESCRIPTION
+
+The constructor must be given a configuration file name:
+
+=over 4
+
+=item * Missing file is B<not> an error.
+
+=item * Other opening errors cause a C<die> to be thrown.
+
+=item * The file name is saved as the value of C<GENCONF_FILE> key.
+
+=back
+
+The access to config keys should only be done via the C<item()> method:
+
+=over 4
+
+=item * It contains all hard-coded defaults.
+
+=item * All these values are overriden by directives in the config file.
+
+=back
+
+=cut
+
+sub new($$) {
+	my $pack = shift || die;
+	my $cfg_file = shift || die;
+	my $self = {
+			GENCONF_FILE	=> $cfg_file,
+		};
+	bless $self, $pack;
+	if(!open(F, $cfg_file)) {
+		if(defined($!{ENOENT})) {
+			#print STDERR "No $cfg_file. Assume empty config\n";
+			return $self; # Empty configuration
+		}
+		die "$pack: Failed to open '$cfg_file': $!\n";
+	}
+	#print STDERR "$pack: $cfg_file\n";
+	my $array_key;
+	while(<F>) {
+		my ($key, $val);
+		chomp;
+		s/#.*$//;
+		s/\s+$//;	# trim tail whitespace
+		next unless /\S/;
+		if(defined $array_key && /^\s+/) {
+			s/^\s+//;	# trim beginning whitespace
+			push(@{$self->{$array_key}}, $_);
+			next; 
+		}
+		undef $array_key;
+		($key, $val) = split(/\s+/, $_, 2);
+		$key = lc($key);
+		if(! defined $val) {
+			$array_key = $key;
+			next;
+		}
+		die "$cfg_file:$.: Duplicate key '$key'\n", if exists $self->{$key};
+		$self->{$key} = $val;
+	}
+	close F;
+	return $self;
+}
+
+sub item($$) {
+	my $self = shift || die;
+	my $key = shift || die;
+	my %defaults = (
+			base_exten		=> '4000',
+			freepbx			=> 'no',	# Better via -F command line
+			fxs_immediate		=> 'no',
+			fxs_default_start	=> 'ks',
+			fxo_default_start	=> 'ks',
+			lc_country		=> 'us',
+			context_lines		=> 'from-pstn',
+			context_phones		=> 'from-internal',
+			context_input		=> 'astbank-input',
+			context_output		=> 'astbank-output',
+			group_phones		=> '5',
+			group_lines		=> '0',
+			brint_overlap		=> 'no',
+			bri_sig_style		=> 'bri_ptmp',
+			echo_can		=> 'mg2',
+			bri_hardhdlc		=> 'auto',
+			pri_connection_type	=> 'PRI',
+			r2_idle_bits		=> '1101',
+			'pri_termtype'		=> [ 'SPAN/* TE' ],
+		);
+
+	return (exists($self->{$key})) ? $self->{$key} :$defaults{$key};
+}
+
+sub dump($) {
+	my $self = shift || die;
+	printf STDERR "%s dump:\n", ref $self;
+	my $width = 30;
+	foreach my $k (sort keys %$self) {
+		my $val = $self->{$k};
+		my $ref = ref $val;
+		#print STDERR "DEBUG: '$k', '$ref', '$val'\n";
+		if($ref eq '') {
+			printf STDERR "%-${width}s %s\n", $k, $val;
+		} elsif($ref eq 'SCALAR') {
+			printf STDERR "%-${width}s %s\n", $k, ${$val};
+		} elsif($ref eq 'ARRAY') {
+			#printf STDERR "%s:\n", $k;
+			my $i = 0;
+			foreach my $v (@{$val}) {
+				printf STDERR "%-${width}s %s\n", "$k\->[$i]", $v;
+				$i++;
+			}
+		} elsif($ref eq 'HASH') {
+			#printf STDERR "%s:\n", $k;
+			foreach my $k1 (keys %{$val}) {
+				printf STDERR "%-${width}s %s\n", "$k\->\{$k1\}", ${$val}{$k1};
+			}
+		} else {
+			printf STDERR "%-${width}s (-> %s)\n", $k, $ref;
+		}
+	}
+}
+
+1;
+

Added: trunk/dahdi-gen/Dahdi/Hardware/PCI.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Hardware/PCI.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Hardware/PCI.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,216 @@
+package Dahdi::Hardware::PCI;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: PCI.pm 6313 2009-04-02 20:56:42Z tzafrir $
+#
+use strict;
+use Dahdi::Utils;
+use Dahdi::Hardware;
+
+our @ISA = qw(Dahdi::Hardware);
+
+# Lookup algorithm:
+# 	First match 'vendor:product/subvendor:subproduct' key
+#	Else match 'vendor:product/subvendor' key
+#	Else match 'vendor:product' key
+#	Else not a dahdi hardware.
+my %pci_ids = (
+	# from wct4xxp
+	'10ee:0314'		=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE410P/TE405P (1st Gen)' },
+	'd161:0420/0004'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE420 (4th Gen)' },
+	'd161:0410/0004'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE410P (4th Gen)' },
+	'd161:0405/0004'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE405P (4th Gen)' },
+	'd161:0410/0003'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE410P (3rd Gen)' },
+	'd161:0405/0003'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE405P (3rd Gen)' },
+	'd161:0410'		=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE410P (2nd Gen)' },
+	'd161:0405'		=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE405P (2nd Gen)' },
+	'd161:0220/0004'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE220 (4th Gen)' },
+	'd161:0205/0004'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE205P (4th Gen)' },
+	'd161:0210/0004'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE210P (4th Gen)' },
+	'd161:0205/0003'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE205P (3rd Gen)' },
+	'd161:0210/0003'	=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE210P (3rd Gen)' },
+	'd161:0205'		=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE205P ' },
+	'd161:0210'		=> { DRIVER => 'wct4xxp', DESCRIPTION => 'Wildcard TE210P ' },
+
+	# from wctdm24xxp
+	'd161:2400'		=> { DRIVER => 'wctdm24xxp', DESCRIPTION => 'Wildcard TDM2400P' },
+	'd161:0800'		=> { DRIVER => 'wctdm24xxp', DESCRIPTION => 'Wildcard TDM800P' },
+	'd161:8002'		=> { DRIVER => 'wctdm24xxp', DESCRIPTION => 'Wildcard AEX800' },
+	'd161:8003'		=> { DRIVER => 'wctdm24xxp', DESCRIPTION => 'Wildcard AEX2400' },
+	'd161:8005'		=> { DRIVER => 'wctdm24xxp', DESCRIPTION => 'Wildcard TDM410P' },
+	'd161:8006'		=> { DRIVER => 'wctdm24xxp', DESCRIPTION => 'Wildcard AEX410P' },
+
+	# from pciradio
+	'e159:0001/e16b'	=> { DRIVER => 'pciradio', DESCRIPTION => 'PCIRADIO' },
+
+	# from wcfxo
+	'e159:0001/8084'	=> { DRIVER => 'wcfxo', DESCRIPTION => 'Wildcard X101P clone' },
+	'e159:0001/8085'	=> { DRIVER => 'wcfxo', DESCRIPTION => 'Wildcard X101P' },
+	'e159:0001/8086'	=> { DRIVER => 'wcfxo', DESCRIPTION => 'Wildcard X101P clone' },
+	'e159:0001/8087'	=> { DRIVER => 'wcfxo', DESCRIPTION => 'Wildcard X101P clone' },
+	'1057:5608'		=> { DRIVER => 'wcfxo', DESCRIPTION => 'Wildcard X100P' },
+
+	# from wct1xxp
+	'e159:0001/6159'	=> { DRIVER => 'wct1xxp', DESCRIPTION => 'Digium Wildcard T100P T1/PRI or E100P E1/PRA Board' },
+
+	# from wctdm
+	'e159:0001/a159'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard S400P Prototype' },
+	'e159:0001/e159'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard S400P Prototype' },
+	'e159:0001/b100'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV E/F' },
+	'e159:0001/b1d9'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV I' },
+	'e159:0001/b118'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV I' },
+	'e159:0001/b119'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV I' },
+	'e159:0001/a9fd'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV H' },
+	'e159:0001/a8fd'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV H' },
+	'e159:0001/a800'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV H' },
+	'e159:0001/a801'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV H' },
+	'e159:0001/a908'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV H' },
+	'e159:0001/a901'	=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV H' },
+	#'e159:0001'		=> { DRIVER => 'wctdm', DESCRIPTION => 'Wildcard TDM400P REV H' },
+
+	# from wcte11xp
+	'e159:0001/71fe'	=> { DRIVER => 'wcte11xp', DESCRIPTION => 'Digium Wildcard TE110P T1/E1 Board' },
+	'e159:0001/79fe'	=> { DRIVER => 'wcte11xp', DESCRIPTION => 'Digium Wildcard TE110P T1/E1 Board' },
+	'e159:0001/795e'	=> { DRIVER => 'wcte11xp', DESCRIPTION => 'Digium Wildcard TE110P T1/E1 Board' },
+	'e159:0001/79de'	=> { DRIVER => 'wcte11xp', DESCRIPTION => 'Digium Wildcard TE110P T1/E1 Board' },
+	'e159:0001/797e'	=> { DRIVER => 'wcte11xp', DESCRIPTION => 'Digium Wildcard TE110P T1/E1 Board' },
+
+	# from wcte12xp
+	'd161:0120'		=> { DRIVER => 'wcte12xp', DESCRIPTION => 'Wildcard TE12xP' },
+	'd161:8000'		=> { DRIVER => 'wcte12xp', DESCRIPTION => 'Wildcard TE121' },
+	'd161:8001'		=> { DRIVER => 'wcte12xp', DESCRIPTION => 'Wildcard TE122' },
+
+	# from wcb4xxp
+	'd161:b410'             => { DRIVER => 'wcb4xxp', DESCRIPTION => 'Digium Wildcard B410P' },
+
+	# from tor2
+	'10b5:9030'		=> { DRIVER => 'tor2', DESCRIPTION => 'PLX 9030' },
+	'10b5:3001'		=> { DRIVER => 'tor2', DESCRIPTION => 'PLX Development Board' },
+	'10b5:d00d'		=> { DRIVER => 'tor2', DESCRIPTION => 'Tormenta 2 Quad T1/PRI or E1/PRA' },
+	'10b5:4000'		=> { DRIVER => 'tor2', DESCRIPTION => 'Tormenta 2 Quad T1/E1 (non-Digium clone)' },
+
+	# Cologne Chips:
+	# (Still a partial list)
+	'1397:08b4/b556'	=> { DRIVER => 'qozap', DESCRIPTION => 'Junghanns DuoBRI ISDN card' },
+	'1397:08b4'		=> { DRIVER => 'qozap', DESCRIPTION => 'Junghanns QuadBRI ISDN card' },
+	'1397:16b8'		=> { DRIVER => 'qozap', DESCRIPTION => 'Junghanns OctoBRI ISDN card' },
+	'1397:30b1'		=> { DRIVER => 'cwain', DESCRIPTION => 'HFC-E1 ISDN E1 card' },
+	'1397:2bd0'		=> { DRIVER => 'zaphfc', DESCRIPTION => 'HFC-S ISDN BRI card' },
+	# Has three submodels. Tested with 0675:1704:
+	'1043:0675'		=> { DRIVER => 'zaphfc', DESCRIPTION => 'ASUSTeK Computer Inc. ISDNLink P-IN100-ST-D' },
+	'1397:f001'		=> { DRIVER => 'ztgsm', DESCRIPTION => 'HFC-GSM Cologne Chips GSM' },
+
+	# Rhino cards (based on pci.ids)
+	'0b0b:0105'	=> { DRIVER => 'r1t1', DESCRIPTION => 'Rhino R1T1' },
+	'0b0b:0205'	=> { DRIVER => 'r4fxo', DESCRIPTION => 'Rhino R14FXO' },
+	'0b0b:0206'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino RCB4FXO 4-channel FXO analog telphony card' },
+	'0b0b:0305'	=> { DRIVER => 'r1t1', DESCRIPTION => 'Rhino R1T1' },
+	'0b0b:0405'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino R8FXX' },
+	'0b0b:0406'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino RCB8FXX 8-channel modular analog telphony card' },
+	'0b0b:0505'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino R24FXX' },
+	'0b0b:0506'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino RCB24FXS 24-Channel FXS analog telphony card' },
+	'0b0b:0605'	=> { DRIVER => 'rxt1', DESCRIPTION => 'Rhino R2T1' },
+	'0b0b:0705'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino R24FXS' },
+	'0b0b:0706'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino RCB24FXO 24-Channel FXO analog telphony card' },
+	'0b0b:0906'	=> { DRIVER => 'rcbfx', DESCRIPTION => 'Rhino RCB24FXX 24-channel modular analog telphony card' },
+
+	# Sangoma cards (based on pci.ids)
+	'1923:0040'	=> { DRIVER => 'wanpipe', DESCRIPTION => 'Sangoma Technologies Corp. A200/Remora FXO/FXS Analog AFT card' },
+	'1923:0100'	=> { DRIVER => 'wanpipe', DESCRIPTION => 'Sangoma Technologies Corp. A104d QUAD T1/E1 AFT card' },
+	'1923:0300'	=> { DRIVER => 'wanpipe', DESCRIPTION => 'Sangoma Technologies Corp. A101 single-port T1/E1' },
+	'1923:0400'	=> { DRIVER => 'wanpipe', DESCRIPTION => 'Sangoma Technologies Corp. A104u Quad T1/E1 AFT' },
+
+	# Yeastar (from output of modinfo):
+	'e159:0001/2151' => { DRIVER => 'ystdm8xx', DESCRIPTION => 'Yeastar YSTDM8xx'},
+	);
+
+$ENV{PATH} .= ":/usr/sbin:/sbin:/usr/bin:/bin";
+
+sub pci_sorter {
+	return $a->priv_device_name() cmp $b->priv_device_name();
+}
+
+sub new($@) {
+	my $pack = shift || die "Wasn't called as a class method\n";
+	my %attr = @_;
+	my $name = sprintf("pci:%s", $attr{PRIV_DEVICE_NAME});
+	my $self = Dahdi::Hardware->new($name, 'PCI');
+	%{$self} = (%{$self}, %attr);
+	bless $self, $pack;
+	return $self;
+}
+
+my %pci_devs;
+
+sub readfile($) {
+	my $name = shift || die;
+	open(F, $name) || die "Failed to open '$name': $!";
+	my $str = <F>;
+	close F;
+	chomp($str);
+	return $str;
+}
+
+sub scan_devices($) {
+	my @devices;
+
+	while(</sys/bus/pci/devices/*>) {
+		m,([^/]+)$,,;
+		my $name = $1;
+		my $l = readlink $_ || die;
+		$pci_devs{$name}{PRIV_DEVICE_NAME} = $name;
+		$pci_devs{$name}{DEVICE} = $l;
+		$pci_devs{$name}{VENDOR} = readfile "$_/vendor";
+		$pci_devs{$name}{PRODUCT} = readfile "$_/device";
+		$pci_devs{$name}{SUBVENDOR} = readfile "$_/subsystem_vendor";
+		$pci_devs{$name}{SUBPRODUCT} = readfile "$_/subsystem_device";
+		my $dev = $pci_devs{$name};
+		grep(s/0x//, $dev->{VENDOR}, $dev->{PRODUCT}, $dev->{SUBVENDOR}, $dev->{SUBPRODUCT});
+		$pci_devs{$name}{DRIVER} = '';
+	}
+
+	while(</sys/bus/pci/drivers/*/[0-9]*>) {
+		m,^(.*?)/([^/]+)/([^/]+)$,;
+		my $prefix = $1;
+		my $drvname = $2;
+		my $id = $3;
+		my $l = readlink "$prefix/$drvname/module";
+		# Find the real module name (if we can).
+		if(defined $l) {
+			my $moduledir = "$prefix/$drvname/$l";
+			my $modname = $moduledir;
+			$modname =~ s:^.*/::;
+			$drvname = $modname;
+		}
+		$pci_devs{$id}{LOADED} = $drvname;
+	}
+	foreach (sort keys %pci_devs) {
+		my $dev = $pci_devs{$_};
+		my $key;
+		# Try to match
+		$key = "$dev->{VENDOR}:$dev->{PRODUCT}/$dev->{SUBVENDOR}:$dev->{SUBPRODUCT}";
+		$key = "$dev->{VENDOR}:$dev->{PRODUCT}/$dev->{SUBVENDOR}" if !defined($pci_ids{$key});
+		$key = "$dev->{VENDOR}:$dev->{PRODUCT}" if !defined($pci_ids{$key});
+		next unless defined $pci_ids{$key};
+
+		my $d = Dahdi::Hardware::PCI->new(
+			PRIV_DEVICE_NAME	=> $dev->{PRIV_DEVICE_NAME},
+			VENDOR			=> $dev->{VENDOR},
+			PRODUCT			=> $dev->{PRODUCT},
+			SUBVENDOR		=> $dev->{SUBVENDOR},
+			SUBPRODUCT		=> $dev->{SUBPRODUCT},
+			LOADED			=> $dev->{LOADED},
+			DRIVER			=> $pci_ids{$key}{DRIVER},
+			DESCRIPTION		=> $pci_ids{$key}{DESCRIPTION},
+			);
+		push(@devices, $d);
+	}
+	@devices = sort pci_sorter @devices;
+	return @devices;
+}
+
+1;

Added: trunk/dahdi-gen/Dahdi/Hardware/USB.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Hardware/USB.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Hardware/USB.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,152 @@
+package Dahdi::Hardware::USB;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: USB.pm 6313 2009-04-02 20:56:42Z tzafrir $
+#
+use strict;
+use Dahdi::Utils;
+use Dahdi::Hardware;
+use Dahdi::Xpp::Mpp;
+
+our @ISA = qw(Dahdi::Hardware);
+
+my %usb_ids = (
+	# from wcusb
+	'06e6:831c'	=> { DRIVER => 'wcusb', DESCRIPTION => 'Wildcard S100U USB FXS Interface' },
+	'06e6:831e'	=> { DRIVER => 'wcusb2', DESCRIPTION => 'Wildcard S110U USB FXS Interface' },
+	'06e6:b210'	=> { DRIVER => 'wc_usb_phone', DESCRIPTION => 'Wildcard Phone Test driver' },
+
+	# from xpp_usb
+	'e4e4:1130'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-8/16 no-firmware' },
+	'e4e4:1131'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-8/16 USB-firmware' },
+	'e4e4:1132'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-8/16 FPGA-firmware' },
+	'e4e4:1140'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-BRI no-firmware' },
+	'e4e4:1141'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-BRI USB-firmware' },
+	'e4e4:1142'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-BRI FPGA-firmware' },
+	'e4e4:1150'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-multi no-firmware' },
+	'e4e4:1151'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-multi USB-firmware' },
+	'e4e4:1152'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-multi FPGA-firmware' },
+	'e4e4:1160'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-modular no-firmware' },
+	'e4e4:1161'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-modular USB-firmware' },
+	'e4e4:1162'	=> { DRIVER => 'xpp_usb', DESCRIPTION => 'Astribank-modular FPGA-firmware' },
+	
+	# Sangoma USB FXO:
+	'10c4:8461'	=> { DRIVER => 'wanpipe', DESCRIPTION => 'Sangoma WANPIPE USB-FXO Device' },
+	);
+
+
+$ENV{PATH} .= ":/usr/sbin:/sbin:/usr/bin:/bin";
+
+sub usb_sorter() {
+	return $a->hardware_name cmp $b->hardware_name;
+}
+
+sub mpp_addinfo($) {
+	my $self = shift || die;
+
+	my $mppinfo = Dahdi::Xpp::Mpp->new($self);
+	$self->{MPPINFO} = $mppinfo if defined $mppinfo;
+}
+
+sub new($@) {
+	my $pack = shift or die "Wasn't called as a class method\n";
+	my %attr = @_;
+	my $name = sprintf("usb:%s", $attr{PRIV_DEVICE_NAME});
+	my $self = Dahdi::Hardware->new($name, 'USB');
+	%{$self} = (%{$self}, %attr);
+	bless $self, $pack;
+	return $self;
+}
+
+sub readval($) {
+	my $fname = shift || warn;
+	open(F, $fname) || warn "Failed opening '$fname': $!";
+	my $val = <F>;
+	close F;
+	chomp $val;
+	warn "$fname is empty" unless defined $val and $val;
+	return $val;
+}
+
+sub set_transport($$) {
+	my $pack = shift || die;
+	my $xbus = shift || die;
+	my $xbus_dir = shift;
+	my $transportdir = "$xbus_dir/transport";
+	my $hwdev;
+	if(! -e "$transportdir/ep_00") {
+		warn "A trasnport in '$transportdir' is not USB";
+		return undef;
+	}
+	my ($usbdev) = glob("$transportdir/usb_device:*");
+	my $busnum;
+	my $devnum;
+	# Different kernels...
+	if(defined $usbdev) {	# It's USB
+		if($usbdev =~ /.*usb_device:usbdev(\d+)\.(\d+)/) {
+			$busnum = $1;
+			$devnum = $2;
+		} else {
+			warn "Bad USB transportdir='$transportdir' usbdev='$usbdev'\n";
+		}
+	} elsif(-d "$transportdir/usb_endpoint") {
+		$busnum = readval("$transportdir/busnum");
+		$devnum = readval("$transportdir/devnum");
+	}
+	my $usbname = sprintf("%03d/%03d", $busnum, $devnum);
+	#printf STDERR "DEBUG: %03d/%03d\n", $busnum, $devnum;
+	$xbus->{USB_DEVNAME} = $usbname;
+	$hwdev = Dahdi::Hardware->device_by_hwname("usb:$usbname");
+	#print "set_transport: ", $hwdev, "\n";
+	$xbus->{TRANSPORT} = $hwdev;
+	$hwdev->{XBUS} = $xbus;
+	$hwdev->{LOADED} = 'xpp_usb';
+	$xbus->{IS_TWINSTAR} = $hwdev->is_twinstar;
+	return $hwdev;
+}
+
+sub scan_devices($) {
+	my $pack = shift || die;
+	my $usb_device_list = "/proc/bus/usb/devices";
+	return unless (-r $usb_device_list);
+
+	my @devices;
+	open(F, $usb_device_list) || die "Failed to open $usb_device_list: $!";
+	local $/ = '';
+	while(<F>) {
+		my @lines = split(/\n/);
+		my ($tline) = grep(/^T/, @lines);
+		my ($pline) = grep(/^P/, @lines);
+		my ($sline) = grep(/^S:.*SerialNumber=/, @lines);
+		my ($busnum,$devnum) = ($tline =~ /Bus=(\w+)\W.*Dev#=\s*(\w+)\W/);
+		my $devname = sprintf("%03d/%03d", $busnum, $devnum);
+		my ($vendor,$product) = ($pline =~ /Vendor=(\w+)\W.*ProdID=(\w+)\W/);
+		my $serial;
+		if(defined $sline) {
+			$sline =~ /SerialNumber=(.*)/;
+			$serial = $1;
+			#$serial =~ s/[[:^print:]]/_/g;
+		}
+		my $model = $usb_ids{"$vendor:$product"};
+		next unless defined $model;
+		my $d = Dahdi::Hardware::USB->new(
+			IS_ASTRIBANK		=> ($model->{DRIVER} eq 'xpp_usb')?1:0,
+			PRIV_DEVICE_NAME	=> $devname,
+			VENDOR			=> $vendor,
+			PRODUCT			=> $product,
+			SERIAL			=> $serial,
+			DESCRIPTION		=> $model->{DESCRIPTION},
+			DRIVER			=> $model->{DRIVER},
+			);
+		push(@devices, $d);
+	}
+	close F;
+	@devices = sort usb_sorter @devices;
+	return @devices;
+}
+
+1;

Added: trunk/dahdi-gen/Dahdi/Hardware.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Hardware.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Hardware.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,221 @@
+package Dahdi::Hardware;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Hardware.pm 6313 2009-04-02 20:56:42Z tzafrir $
+#
+use strict;
+
+=head1 NAME
+
+Dahdi::Hardware - Perl interface to a Dahdi devices listing
+
+
+  use Dahdi::Hardware;
+  
+  my $hardware = Dahdi::Hardware->scan; 
+  
+  # mini dahdi_hardware:
+  foreach my $device ($hardware->device_list) {
+    print "Vendor: device->{VENDOR}, Product: $device->{PRODUCT}\n"
+  }
+
+  # let's see if there are devices without loaded drivers, and sugggest
+  # drivers to load:
+  my @to_load = ();
+  foreach my $device ($hardware->device_list) {
+    if (! $device->{LOADED} ) {
+      push @to_load, ($device->${DRIVER});
+    }
+  }
+  if (@to_load) {
+    print "To support the extra devices you probably need to run:\n"
+    print "  modprobe ". (join ' ', @to_load). "\n";
+  }
+
+
+This module provides information about available Dahdi devices on the
+system. It identifies devices by (USB/PCI) bus IDs.
+
+
+=head1 Device Attributes
+
+As usual, object attributes can be used in either upp-case or
+lower-case, or lower-case functions.
+
+=head2 bus_type
+
+'PCI' or 'USB'.
+
+
+=head2 description
+
+A one-line description of the device.
+
+
+=head2 driver
+
+Name of a Dahdi device driver that should handle this device. This is
+based on a pre-made list.
+
+
+=head2 vendor, product, subvendor, subproduct
+
+The PCI and USB vendor ID, product ID, sub-vendor ID and sub-product ID.
+(The standard short lspci and lsusb listings show only vendor and
+product IDs).
+
+
+=head2 loaded
+
+If the device is handled by a module - the name of the module. Else -
+undef.
+
+
+=head2 priv_device_name
+
+A string that shows the "location" of that device on the bus.
+
+
+=head2 is_astribank
+
+True if the device is a Xorcom Astribank (which may provide some extra
+attributes).
+
+=head2 serial
+
+(Astribank-specific attrribute) - the serial number string of the
+Astribank.
+
+=cut
+#
+# A global hardware handle
+#
+
+my %hardware_list = (
+			'PCI'	=> [],
+			'USB'	=> [],
+		);
+
+
+sub new($$) {
+	my $pack = shift || die "Wasn't called as a class method\n";
+	my $name =  shift || die "$0: Missing device name";
+	my $type =  shift || die "$0: Missing device type";
+	my $dev = {};
+	$dev->{'BUS_TYPE'} = $type;
+	$dev->{IS_ASTRIBANK} = 0 unless defined $dev->{'IS_ASTRIBANK'};
+	$dev->{'HARDWARE_NAME'} = $name;
+	return $dev;
+}
+
+=head1 device_list()
+
+Returns a list of the hardware devices on the system.
+
+You must run scan() first for this function to run meaningful output.
+
+=cut
+
+sub device_list($) {
+	my $pack = shift || die;
+	my @types = @_;
+	my @list;
+
+	@types = qw(USB PCI) unless @types;
+	foreach my $t (@types) {
+		my $lst = $hardware_list{$t};
+		@list = ( @list, @{$lst} );
+	}
+	return @list;
+}
+
+sub device_by_hwname($$) {
+	my $pack = shift || die;
+	my $name = shift || die;
+	my @list = device_list('localcall');
+
+	my @good = grep { $_->hardware_name eq $name } @list;
+	return undef unless @good;
+	@good > 1 && die "$pack: Multiple matches for '$name': @good";
+	return $good[0];
+}
+
+=head1 drivers()
+
+Returns a list of drivers (currently sorted by name) that are used by
+the devices in the current system (regardless to whether or not they are
+loaded.
+
+=cut
+
+sub drivers($) {
+	my $self = shift || die;
+	my @devs = device_list('localcall');
+	my @drvs = map { $_->{DRIVER} } @devs;
+	# Make unique
+	my %drivers;
+	@drivers{@drvs} = 1;
+	return sort keys %drivers;
+}
+
+
+=head1 scan()
+
+Scan the system for Dahdi devices (PCI and USB). Returns nothing but
+must be run to initialize the module.
+
+=cut
+
+my $hardware_scanned;
+
+sub scan($) {
+	my $pack = shift || die;
+
+	return if $hardware_scanned++;
+	foreach my $type (qw(PCI USB)) {
+		eval "use Dahdi::Hardware::$type";
+		die $@ if $@;
+		$hardware_list{$type} = [ "Dahdi::Hardware::$type"->scan_devices ];
+	}
+}
+
+sub import {
+	Dahdi::Hardware->scan unless grep(/\bnoscan\b/i, @_);
+}
+
+sub showall {
+	my $pack = shift || die;
+	my @devs;
+
+	my $printer = sub {
+			my $title = shift;
+			my @devs = @_;
+
+			return unless @devs;
+			printf "%s:\n", $title;
+			foreach my $dev (@devs) {
+				printf "\t%s\n", $dev->hardware_name;
+				foreach my $k (sort keys %{$dev}) {
+					my $v = $dev->{$k};
+					if($k eq 'MPPINFO') {
+						printf "\t\tMPPINFO:\n";
+						eval "use Dahdi::Xpp::Mpp";
+						die $@ if $@;
+						$v->showinfo("\t\t  ");
+					} else {
+						printf "\t\t%-20s %s\n", $k, $v;
+					}
+				}
+			}
+		};
+	foreach my $type (qw(USB PCI)) {
+		my $lst = $hardware_list{$type};
+		&$printer("$type devices", @{$lst});
+	}
+}
+
+1;

Added: trunk/dahdi-gen/Dahdi/Span.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Span.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Span.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,356 @@
+package Dahdi::Span;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Span.pm 6613 2009-05-13 10:37:08Z tzafrir $
+#
+use strict;
+use Dahdi::Utils;
+use Dahdi::Chans;
+use Dahdi::Xpp::Xpd;
+
+=head1 NAME
+
+Dahdi::Spans - Perl interface to a Dahdi span information
+
+This package allows access from perl to information about a Dahdi
+channel. It is part of the Dahdi Perl package.
+
+A span is a logical unit of Dahdi channels. Normally a port in a
+digital card or a whole analog card.
+
+See documentation of module L<Dahdi> for usage example. Specifically
+C<Dahdi::spans()> must be run initially.
+
+=head1 by_number()
+
+Get a span by its Dahdi span number.
+
+=head1 Span Properties
+
+=head2 num()
+
+The span number.
+
+=head2 name()
+
+The name field of a Dahdi span. E.g.:
+
+  TE2/0/1
+
+=head2 description()
+
+The description field of the span. e.g:
+
+  "T2XXP (PCI) Card 0 Span 1" HDB3/CCS/CRC4 RED
+
+=head2 chans()
+
+The list of the channels (L<Dahdi::Chan> objects) of this span.
+In a scalar context returns the number of channels this span has.
+
+=head2 bchans()
+
+Likewise a list of bchannels (or a count in a scalar context).
+
+=head2 is_sync_master()
+
+Is this span the source of timing for Dahdi?
+
+=head2 type()
+
+Type of span, or "UNKNOWN" if could not be detected. Current known
+types: 
+
+BRI_TE, BRI_NT, E1_TE, E1_NT, J1_TE, J1_NT, T1_TE, T1_NT, FXS, FXO
+
+=head2 is_pri()
+
+Is this an E1/J1/T1 span?
+
+=head2 is_bri()
+
+Is this a BRI span?
+
+=head2 is_digital()
+
+Is this a digital (as opposed to analog) span?
+
+=head2 termtype()
+
+Set for digital spans. "TE" or "NT". Will probably be assumed to be "TE"
+if there's no information pointing either way.
+
+=head2 coding()
+
+Suggested sane coding type (e.g.: "hdb3", "b8zs") for this type of span. 
+
+=head2 framing()
+
+Suggested sane framing type (e.g.: "ccs", "esf") for this type of span. 
+
+=head2 yellow(), crc4()
+
+Likewise, suggestions ofr the respective fields in the span= line in
+/etc/dahdi/system.conf for this span.
+
+=head2 signalling()
+
+Suggested chan_dahdi.conf signalling for channels of this span.
+
+=head2 switchtype()
+
+Suggested chan_dahdi.conf switchtype for channels of this span.
+
+=head1 Note
+
+Most of those properties are normally used as lower-case functions, but
+actually set in the module as capital-letter propeties. To look at e.g.
+"signalling" is set, look for "SIGNALLING".
+
+=cut
+
+my $proc_base = "/proc/dahdi";
+
+sub chans($) {
+	my $span = shift;
+	return @{$span->{CHANS}};
+}
+
+sub by_number($) {
+	my $span_number = shift;
+	die "Missing span number" unless defined $span_number;
+	my @spans = Dahdi::spans();
+
+	my ($span) = grep { $_->num == $span_number } @spans;
+	return $span;
+}
+
+my @bri_strings = (
+		'BRI_(NT|TE)',
+		'(?:quad|octo)BRI PCI ISDN Card.* \[(NT|TE)\]\ ',
+		'octoBRI \[(NT|TE)\] ',
+		'HFC-S PCI A ISDN.* \[(NT|TE)\] ',
+		'(B4XXP) \(PCI\) Card', # Does not expose NT/TE type
+		);
+
+my @pri_strings = (
+		'Tormenta 2 .*Quad (E1|T1)',       # tor2.
+		'Xorcom XPD.*: (E1|T1)',           # Astribank PRI
+		'Digium Wildcard .100P (T1|E1)/', # wct1xxp
+		'ISA Tormenta Span 1',	           # torisa
+		'TE110P T1/E1',                    # wcte11xp
+		'Wildcard TE120P',                 # wcte12xp
+		'Wildcard TE121',                  # wcte12xp
+		'Wildcard TE122',                  # wcte12xp
+		'T[24]XXP \(PCI\) Card ',          # wct4xxp
+		'R[24]T1 \(PCI\) Card',            # rxt1
+		'Rhino R1T1 (E1)/PRA Card',        # r1t1
+		'Rhino R1T1 (T1)/PRI Card',        # r1t1
+		);
+
+our $DAHDI_BRI_NET = 'bri_net';
+our $DAHDI_BRI_CPE = 'bri_cpe';
+
+our $DAHDI_PRI_NET = 'pri_net';
+our $DAHDI_PRI_CPE = 'pri_cpe';
+
+sub init_proto($$) {
+	my $self = shift;
+	my $proto = shift;
+
+	$self->{PROTO} = $proto;
+	if($proto eq 'E1') {
+		$self->{DCHAN_IDX} = 15;
+		$self->{BCHAN_LIST} = [ 0 .. 14, 16 .. 30 ];
+	} elsif($proto eq 'T1') {
+		$self->{DCHAN_IDX} = 23;
+		$self->{BCHAN_LIST} = [ 0 .. 22 ];
+	}
+	$self->{TYPE} = "${proto}_$self->{TERMTYPE}";
+}
+
+sub new($$) {
+	my $pack = shift or die "Wasn't called as a class method\n";
+	my $num = shift or die "Missing a span number parameter\n";
+	my $self = { NUM => $num };
+	bless $self, $pack;
+	$self->{TYPE} = "UNKNOWN";
+	my @xpds = Dahdi::Xpp::Xpd::xpds_by_spanno;
+	my $xpd = $xpds[$num];
+	if(defined $xpd) {
+		die "Spanno mismatch: $xpd->spanno, $num" unless $xpd->spanno == $num;
+		$self->{XPD} = $xpd;
+	}
+	open(F, "$proc_base/$num") or die "Failed to open '$proc_base/$num\n";
+	my $head = <F>;
+	chomp $head;
+	$self->{IS_DIGITAL} = 0;
+	$self->{IS_BRI} = 0;
+	$self->{IS_PRI} = 0;
+	foreach my $cardtype (@bri_strings) {
+		if($head =~ m/$cardtype/) {
+			my $termtype = $1;
+			$termtype = 'TE' if ( $1 eq 'B4XXP' );
+			$self->{IS_DIGITAL} = 1;
+			$self->{IS_BRI} = 1;
+			$self->{TERMTYPE} = $termtype;
+			$self->{TYPE} = "BRI_$termtype";
+			$self->{DCHAN_IDX} = 2;
+			$self->{BCHAN_LIST} = [ 0, 1 ];
+			last;
+		}
+	}
+	foreach my $cardtype (@pri_strings) {
+		if($head =~ m/$cardtype/) {
+			my @info;
+
+			push(@info, $1) if defined $1;
+			push(@info, $2) if defined $2;
+			my ($proto) = grep(/(E1|T1|J1)/, @info);
+			$proto = 'UNKNOWN' unless defined $proto;
+			my ($termtype) = grep(/(NT|TE)/, @info);
+			$termtype = 'UNKNOWN' unless defined $termtype;
+
+			$self->{IS_DIGITAL} = 1;
+			$self->{IS_PRI} = 1;
+			$self->{TERMTYPE} = $termtype;
+			$self->init_proto($proto);
+			last;
+		}
+	}
+	($self->{NAME}, $self->{DESCRIPTION}) = (split(/\s+/, $head, 4))[2, 3];
+	$self->{IS_DAHDI_SYNC_MASTER} =
+		($self->{DESCRIPTION} =~ /\(MASTER\)/) ? 1 : 0;
+	$self->{CHANS} = [];
+	my @channels;
+	my $index = 0;
+	while(<F>) {
+		chomp;
+		s/^\s*//;
+		s/\s*$//;
+		next unless /\S/;
+		next unless /^\s*\d+/; # must be a real channel string.
+		my $c = Dahdi::Chans->new($self, $index, $_);
+		push(@channels, $c);
+		$index++;
+	}
+	close F;
+	if($self->is_pri()) {
+		# Check for PRI with unknown type strings
+		if($index == 31) {
+			if($self->{PROTO} eq 'UNKNOWN') {
+				$self->init_proto('E1');
+			} elsif($self->{PROTO} ne 'E1')  {
+				die "$index channels in a $self->{PROTO} span";
+			}
+		} elsif($index == 24) {
+			if($self->{PROTO} eq 'UNKNOWN') {
+				$self->init_proto('T1');	# FIXME: J1?
+			} elsif($self->{PROTO} ne 'T1') {
+				die "$index channels in a $self->{PROTO} span";
+			}
+		}
+	}
+	@channels = sort { $a->num <=> $b->num } @channels;
+	$self->{CHANS} = \@channels;
+	$self->{YELLOW} = undef;
+	$self->{CRC4} = undef;
+	if($self->is_bri()) {
+		$self->{CODING} = 'ami';
+		$self->{DCHAN} = ($self->chans())[$self->{DCHAN_IDX}];
+		$self->{BCHANS} = [ ($self->chans())[@{$self->{BCHAN_LIST}}] ];
+		# Infer some info from channel name:
+		my $first_chan = ($self->chans())[0] || die "$0: No channels in span #$num\n";
+		my $chan_fqn = $first_chan->fqn();
+		if($chan_fqn =~ m(ZTHFC.*/|ztqoz.*/|XPP_BRI_.*|B4/.*)) {		# BRI
+			$self->{FRAMING} = 'ccs';
+			$self->{SWITCHTYPE} = 'euroisdn';
+			$self->{SIGNALLING} = ($self->{TERMTYPE} eq 'NT') ? $DAHDI_BRI_NET : $DAHDI_BRI_CPE ;
+		} elsif($chan_fqn =~ m(ztgsm.*/)) {				# Junghanns's GSM cards. 
+			$self->{FRAMING} = 'ccs';
+			$self->{SIGNALLING} = 'gsm';
+		}
+	}
+	if($self->is_pri()) {
+		$self->{DCHAN} = ($self->chans())[$self->{DCHAN_IDX}];
+		$self->{BCHANS} = [ ($self->chans())[@{$self->{BCHAN_LIST}}] ];
+		if($self->{PROTO} eq 'E1') {
+			$self->{CODING} = 'hdb3';
+			$self->{FRAMING} = 'ccs';
+			$self->{SWITCHTYPE} = 'euroisdn';
+			$self->{CRC4} = 'crc4';
+		} elsif($self->{PROTO} eq 'T1') {
+			$self->{CODING} = 'b8zs';
+			$self->{FRAMING} = 'esf';
+			$self->{SWITCHTYPE} = 'national';
+		} else {
+			die "'$self->{PROTO}' unsupported yet";
+		}
+	}
+	return $self;
+}
+
+sub bchans($) {
+	my $self = shift || die;
+
+	return @{$self->{BCHANS}};
+}
+
+sub set_termtype($$) {
+	my $span = shift || die;
+	my $termtype = shift || die;
+	$span->{TERMTYPE} = $termtype;
+	$span->{SIGNALLING} = ($termtype eq 'NT') ? $DAHDI_PRI_NET : $DAHDI_PRI_CPE ;
+	$span->{TYPE} = $span->proto . "_$termtype";
+}
+
+sub pri_set_fromconfig($$) {
+	my $span = shift || die;
+	my $genconf = shift || die;
+	my $name = $span->name;
+#	if(defined $termtype) {
+#		die "Termtype for $name already defined as $termtype\n";
+#	}
+	my $pri_termtype = $genconf->{pri_termtype};
+	my @pri_specs;
+	if(defined $pri_termtype) {
+		@pri_specs = @{$pri_termtype};
+	}
+	push(@pri_specs , 'SPAN/* TE');		# Default
+	my @patlist = ( "SPAN/" . $span->num );
+	my ($xbus_name, $xpd_name) = ($name =~ m|(XBUS-\d+)/(XPD-\d+)|);
+	if(defined $xbus_name) {
+		push(@patlist, "NUM/$xbus_name/$xpd_name");
+#		push(@patlist, "CONNECTOR/$ENV{XBUS_CONNECTOR}/$xpd_name");
+	}
+	#print STDERR "PATLIST=@patlist\n";
+	my $match_termtype;
+SPEC:
+	for(my $i = 0; $i < @pri_specs; $i++) {
+		my $spec = $pri_specs[$i];
+		#print STDERR "spec: $spec\n";
+		my ($match, $termtype) = split(/\s+/, $spec);
+		next unless defined $match and defined $termtype;
+		# Convert "globs" to regex
+		$match =~ s/\*/.*/g;
+		$match =~ s/\?/./g;
+		#print STDERR "match: $match\n";
+		foreach my $pattern (@patlist) {
+			#print STDERR "testmatch: $pattern =~ $match\n";
+			if($pattern =~ $match) {
+				#print STDERR "$xpd_name: MATCH '$pattern' ~ '$match' termtype=$termtype\n";
+				$match_termtype = $termtype;
+				last SPEC;
+			}
+		}
+	}
+	die "Unknown pri_termtype" unless defined $match_termtype;
+	$span->set_termtype($match_termtype);
+}
+
+
+1;

Added: trunk/dahdi-gen/Dahdi/Utils.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Utils.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Utils.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,52 @@
+package Dahdi::Utils;
+
+# Accessors (miniperl does not have Class:Accessor)
+our $AUTOLOAD;
+sub AUTOLOAD {
+	my $self = shift;
+	my $name = $AUTOLOAD;
+	$name =~ s/.*://;   # strip fully-qualified portion
+	return if $name =~ /^[A-Z_]+$/;	# ignore special methods (DESTROY)
+	my $key = uc($name);
+	my $val = shift;
+	if (defined $val) {
+		#print STDERR "set: $key = $val\n";
+		return $self->{$key} = $val;
+	} else {
+		if(!exists $self->{$key}) {
+			#$self->xpp_dump;
+			#die "Trying to get uninitialized '$key'";
+		}
+		my $val = $self->{$key};
+		#print STDERR "get: $key ($val)\n";
+		return $val;
+	}
+}
+
+sub xpp_dump($) {
+	my $self = shift || die;
+	printf STDERR "Dump a %s\n", ref($self);
+	foreach my $k (sort keys %{$self}) {
+		my $val = $self->{$k};
+		$val = '**UNDEF**' if !defined $val;
+		printf STDERR "    %-20s %s\n", $k, $val;
+	}
+}
+
+# Based on Autoloader
+
+sub import {
+	my $pkg = shift;
+	my $callpkg = caller;
+
+	#print STDERR "import: $pkg, $callpkg\n";
+	#
+	# Export symbols, but not by accident of inheritance.
+	#
+	die "Sombody inherited Dahdi::Utils" if $pkg ne 'Dahdi::Utils';
+	no strict 'refs';
+	*{ $callpkg . '::AUTOLOAD' } = \&AUTOLOAD;
+	*{ $callpkg . '::xpp_dump' } = \&xpp_dump;
+}
+
+1;

Added: trunk/dahdi-gen/Dahdi/Xpp/Line.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Xpp/Line.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Xpp/Line.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,89 @@
+package Dahdi::Xpp::Line;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2008, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Line.pm 5671 2009-01-18 10:22:27Z tzafrir $
+#
+use strict;
+use Dahdi::Utils;
+
+sub new($$$) {
+	my $pack = shift or die "Wasn't called as a class method\n";
+	my $xpd = shift or die;
+	my $index = shift;
+	defined $index or die;
+	my $self = {};
+	bless $self, $pack;
+	$self->{XPD} = $xpd;
+	$self->{INDEX} = $index;
+	return $self;
+}
+
+sub blink($$) {
+	my $self = shift;
+	my $on = shift;
+	my $xpd = $self->xpd;
+	my $result = $xpd->xpd_getattr("blink");
+	$result = hex($result);
+	if(defined($on)) {		# Now change
+		my $onbitmask = 1 << $self->index;
+		my $offbitmask = $result & ~$onbitmask;
+
+		$result = $offbitmask;
+		$result |= $onbitmask if $on;
+		$result = $xpd->xpd_setattr("blink", $result);
+	}
+	return $result;
+}
+
+sub create_all($$) {
+	my $pack = shift or die "Wasn't called as a class method\n";
+	my $xpd = shift || die;
+	my $procdir = shift || die;
+	local $/ = "\n";
+	my @lines;
+	for(my $i = 0; $i < $xpd->{CHANNELS}; $i++) {
+		my $line = Dahdi::Xpp::Line->new($xpd, $i);
+		push(@lines, $line);
+	}
+	$xpd->{LINES} = \@lines;
+	if($xpd->type eq 'FXO') {
+		my $battery = $xpd->xpd_getattr("fxo_battery");
+		if(defined $battery) {
+			my @batt = split(/\s+/, $battery);
+			foreach my $l (@lines) {
+				die unless @batt;
+				my $state = shift @batt;
+				$l->{BATTERY} = ($state eq '+') ? 1 : 0;
+			}
+		} else {
+			# Fallback to old interface
+			my ($infofile) = glob "$procdir/*_info";
+			die "Failed globbing '$procdir/*_info'" unless defined $infofile;
+			open(F, "$infofile") || die "Failed opening '$infofile': $!";
+			my $battery_info = 0;
+			while (<F>) {
+				chomp;
+				$battery_info = 1 if /^Battery:/;
+				if($battery_info && s/^\s*on\s*:\s*//) {
+					my @batt = split;
+					foreach my $l (@lines) {
+						die unless @batt;
+						my $state = shift @batt;
+						$l->{BATTERY} = ($state eq '+') ? 1 : 0;
+					}
+					$battery_info = 0;
+					die if @batt;
+				}
+			}
+			close F;
+		}
+	}
+	close F;
+}
+
+
+1;

Added: trunk/dahdi-gen/Dahdi/Xpp/Mpp.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Xpp/Mpp.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Xpp/Mpp.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,221 @@
+package Dahdi::Xpp::Mpp;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2009, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Mpp.pm 6630 2009-05-16 22:46:57Z tzafrir $
+#
+use strict;
+use File::Basename;
+use Getopt::Std;
+BEGIN { my $dir = dirname($0); unshift(@INC, "$dir", "$dir/perl_modules"); }
+
+use Dahdi::Utils;
+
+=head1 NAME
+
+Dahdi::Xpp::Mpp - Perl interface to C<astribank_tool(8)>
+
+=head1 DESCRIPTION
+
+This package uses C<astribank_tool(8)> to collect information
+about Astribanks via MPP (Management Processor Protocol).
+
+The binary default location is F</usr/sbin/astribank_tool>. It may be
+overridden via module parameter C<astribank_tool=> and the
+C<ASTRIBANK_TOOL> environment variable (higher priority).
+
+It may also be set/unset from code via the set_astribank_tool() method.
+
+=head1 METHODS
+
+=head2 mpp_addinfo()
+
+Called with a list of C<Dahdi::Hardware> objects and augment their
+data with C<Dahdi::Xpp::Mpp> objects.
+
+This method is the normal external interface of this class.
+
+=head2 new()
+
+Constructor. Receive as parameter an instance of C<Dahdi::Hardware> class
+and return a C<Dahdi::Xpp:Mpp> object.
+
+Normally, used indirectly via the mpp_addinfo() method.
+
+=head2 set_astribank_tool()
+
+Override default location of astribank_tool(8). It is legal
+to set it to C<undef>.
+
+=head2 showinfo()
+
+Dump an C<Dahdi::Xpp::Mpp> object for debugging.
+
+=cut
+
+my $astribank_tool = '/usr/sbin/astribank_tool';
+
+sub set_astribank_tool($$) {
+	my $pack = shift || die;
+	$pack eq 'Dahdi::Xpp::Mpp' or die "$0: Called from wrong package? ($pack)";
+	my $arg = shift;
+	$astribank_tool = $arg;
+	#print STDERR "Setting astribank_tool='$astribank_tool'\n";
+}
+
+sub import {
+	my ($param) = grep(/^astribank_tool=/, @_);
+	if(defined $param) {
+		$param =~ s/^astribank_tool=//;
+		$astribank_tool = $param;
+	}
+	if(defined $ENV{ASTRIBANK_TOOL}) {
+		$astribank_tool = $ENV{ASTRIBANK_TOOL};
+	}
+}
+
+sub showinfo($$) {
+	my $self = shift || die;
+	my $prefix = shift || die;
+
+	return unless defined $self;
+	foreach my $k (sort keys %{$self}) {
+		my $v = $self->{$k};
+		if(ref($v) eq 'ARRAY') {
+			my @a = @{$v};
+			my $i;
+			my $ki;
+			for($i = 0; $i < @a; $i++) {
+				$ki = sprintf "%s[%d]", $k, $i;
+				printf "$prefix%-20s %s\n", $ki, $a[$i];
+			}
+		} else {
+			if($k eq 'DEV') {
+				printf "$prefix%-20s -> %s\n", $k, $v->hardware_name;
+			} else {
+				printf "$prefix%-20s %s\n", $k, $v;
+			}
+		}
+	}
+}
+
+sub astribank_tool_cmd($) {
+	my $dev = shift || die;
+	my $usb_top;
+
+	# Find USB bus toplevel
+	$usb_top = '/dev/bus/usb';
+	$usb_top = '/proc/bus/usb' unless -d $usb_top;
+	die "No USB toplevel found\n" unless -d $usb_top;
+	my $name = $dev->priv_device_name();
+	die "$0: Unkown private device name" unless defined $name;
+	my $path = "$usb_top/$name";
+	return ($astribank_tool, '-D', "$path");
+}
+
+sub new($$$) {
+	my $pack = shift || die;
+	my $dev = shift || die;
+	my $product = $dev->product;
+
+	return undef unless $dev->is_astribank;
+	return undef unless $dev->bus_type eq 'USB';
+	return undef unless $product =~ /116./;
+	my $mppinfo = {
+			DEV	=> $dev,
+			HAS_MPP	=> 1,
+		};
+	bless $mppinfo, $pack;
+	#print STDERR "$astribank_tool($path) -- '$product'\n";
+	if(! -x $astribank_tool) {
+		warn "Could not run '$astribank_tool'\n";
+		return $mppinfo;
+	}
+	return $mppinfo unless $product =~ /116[12]/;
+	$mppinfo->{'MPP_TALK'} = 1;
+	my @cmd = astribank_tool_cmd($dev);
+	my $name = $dev->priv_device_name();
+	my $dbg_file = "$name";
+	$dbg_file =~ s/\W/_/g;
+	#$dbg_file = "/tmp/twinstar-debug-$dbg_file";
+	$dbg_file = "/dev/null";
+	unless(open(F, "@cmd 2> '$dbg_file' |")) {
+		warn "Failed running '$astribank_tool': $!";
+		return undef;
+	}
+	local $/ = "\n";
+	local $_;
+	while(<F>) {
+		chomp;
+		#printf STDERR "'%s'\n", $_;
+		if(s/^INFO:\s*//) {
+			$mppinfo->{'PROTOCOL'} = $1 if /^protocol\s+version:\s*(\d+)/i;
+		} elsif(s/^EEPROM:\s*//) {
+			$mppinfo->{'EEPROM_RELEASE'} = $1 if /^release\s*:\s*([\d\.]+)/i;
+			$mppinfo->{'EEPROM_LABEL'} = $1 if /^label\s*:\s*([\w._'-]+)/i;
+		} elsif(s/^Extrainfo:\s+:\s*(.+?)$//) {
+			$mppinfo->{'EEPROM_EXTRAINFO'} = $1;
+		} elsif(s/^Capabilities:\s*TwinStar\s*:\s*(.+?)$//) {
+			my $cap = $1;
+			$mppinfo->{'TWINSTAR_CAPABLE'} = ($cap =~ /yes/i) ? 1 : 0;
+		} elsif(s/^TwinStar:\s*//) {
+			$mppinfo->{'TWINSTAR_PORT'} = $1 if /^connected\s+to\s*:\s*usb-(\d+)/i;
+			if(s/^USB-(\d+)\s*POWER\s*:\s*//) {
+				my $v = ($_ eq 'ON') ? 1 : 0;
+				$mppinfo->{'TWINSTAR_POWER'}->[$1] = $v;
+			}
+			if(s/^Watchdog[^:]+:\s*//) {
+				my $v = ($_ eq 'on-guard') ? 1 : 0;
+				$mppinfo->{'TWINSTAR_WATCHDOG'} = $v;
+			}
+			#printf STDERR "\t%s\n", $_;
+		} else {
+			#printf STDERR "\t%s\n", $_;
+		}
+	}
+	unless(close F) {
+		warn "Failed running '$astribank_tool': $!";
+		return undef;
+	}
+	#$mppinfo->showinfo;
+	return $mppinfo;
+}
+
+sub mpp_setwatchdog($$) {
+	my $mppinfo = shift || die;
+	my $on = shift;
+	die "$0: Bad value '$on'" unless defined($on) && $on =~ /^[0-1]$/;
+	my $dev = $mppinfo->dev || die;
+	return undef unless defined $mppinfo->mpp_talk;
+	my $old = $mppinfo->tws_watchdog;
+	my @cmd = astribank_tool_cmd($dev);
+	print STDERR "DEBUG($on): '@cmd'\n";
+	system(@cmd, '-w', $on);
+	die "Running $astribank_tool failed: $?" if $?;
+}
+
+sub mpp_jump($) {
+	my $mppinfo = shift || die;
+	my $dev = $mppinfo->dev || die;
+	return undef unless defined $mppinfo->mpp_talk;
+	my $port = $mppinfo->twinstar_port;
+	$port = ($port == 1) ? 0 : 1;
+	die "Unknown TwinStar port" unless defined $port;
+	my @cmd = astribank_tool_cmd($dev);
+	system(@cmd, '-p', $port);
+	die "Running $astribank_tool failed: $?" if $?;
+}
+
+sub mpp_addinfo($@) {
+	my $pack = shift || die;
+	my @devlist = @_;
+
+	foreach my $dev (@devlist) {
+		$dev->{MPPINFO} = $pack->new($dev);
+	}
+}
+
+1;

Added: trunk/dahdi-gen/Dahdi/Xpp/Xbus.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Xpp/Xbus.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Xpp/Xbus.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,215 @@
+package Dahdi::Xpp::Xbus;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Xbus.pm 6417 2009-04-20 13:44:35Z tzafrir $
+#
+use strict;
+use Dahdi::Utils;
+use Dahdi::Hardware;
+use Dahdi::Xpp::Xpd;
+
+my $proc_base = "/proc/xpp";
+
+sub xpds($) {
+	my $xbus = shift;
+	return @{$xbus->{XPDS}};
+}
+
+sub by_number($) {
+	my $busnumber = shift;
+	die "Missing xbus number parameter" unless defined $busnumber;
+	my @xbuses = Dahdi::Xpp::xbuses();
+
+	my ($xbus) = grep { $_->num == $busnumber } @xbuses;
+	return $xbus;
+}
+
+sub by_label($) {
+	my $label = shift;
+	die "Missing xbus label parameter" unless defined $label;
+	my @xbuses = Dahdi::Xpp::xbuses();
+
+	my ($xbus) = grep { $_->label eq $label } @xbuses;
+	return $xbus;
+}
+
+sub get_xpd_by_number($$) {
+	my $xbus = shift;
+	my $xpdid = shift;
+	die "Missing XPD id parameter" unless defined $xpdid;
+	$xpdid = sprintf("%02d", $xpdid);
+	my @xpds = $xbus->xpds;
+	my ($wanted) = grep { $_->id eq $xpdid } @xpds;
+	return $wanted;
+}
+
+my %file_warned;	# Prevent duplicate warnings about same file.
+
+sub xbus_attr_path($$) {
+	my ($busnum, @attr) = @_;
+	foreach my $attr (@attr) {
+		my $file = sprintf "$Dahdi::Xpp::sysfs_astribanks/xbus-%02d/$attr", $busnum;
+		unless(-f $file) {
+			my $procfile = sprintf "/proc/xpp/XBUS-%02d/$attr", $busnum;
+			warn "$0: warning - OLD DRIVER: missing '$file'. Fall back to '$procfile'\n"
+				unless $file_warned{$attr}++;
+			$file = $procfile;
+		}
+		next unless -f $file;
+		return $file;
+	}
+	return undef;
+}
+
+sub xbus_getattr($$) {
+	my $xbus = shift || die;
+	my $attr = shift || die;
+	$attr = lc($attr);
+	my $file = xbus_attr_path($xbus->num, lc($attr));
+
+	open(F, $file) || die "Failed opening '$file': $!";
+	my $val = <F>;
+	close F;
+	chomp $val;
+	return $val;
+}
+
+sub read_attrs() {
+	my $xbus = shift || die;
+	my @attrnames = qw(CONNECTOR LABEL STATUS);
+	my @attrs;
+
+	foreach my $attr (@attrnames) {
+		my $val = xbus_getattr($xbus, $attr);
+		if($attr eq 'STATUS') {
+			# Some values are in all caps as well
+			$val = uc($val);
+		} elsif($attr eq 'CONNECTOR') {
+			$val =~ s/^/@/;	# Add prefix
+		} elsif($attr eq 'LABEL') {
+			# Fix badly burned labels.
+			$val =~ s/[[:^print:]]/_/g;
+		}
+		$xbus->{$attr} = $val;
+	}
+}
+
+sub transport_type($$) {
+	my $xbus = shift || die;
+	my $xbus_dir = shift;
+	my $transport = "$xbus_dir/transport";
+	if(-e "$transport/ep_00") {	# It's USB
+		$xbus->{TRANSPORT_TYPE} = 'USB';
+	} else {
+		warn "Unkown transport in $xbus_dir\n";
+		undef $xbus->{TRANSPORT_TYPE};
+	}
+	return $xbus->{TRANSPORT_TYPE};
+}
+
+sub read_xpdnames_old($) {
+	my $xbus_num = shift || die;
+	my $pat = sprintf "/proc/xpp/XBUS-%02d/XPD-[0-9][0-9]", $xbus_num;
+	my @xpdnames;
+
+	#print STDERR "read_xpdnames_old($xbus_num): $pat\n";
+	foreach (glob $pat) {
+		die "Bad /proc entry: '$_'" unless /^.*XPD-([0-9])([0-9])$/;
+		my $name = sprintf("%02d:%1d:%1d", $xbus_num, $1, $2);
+		#print STDERR "\t> $_ ($name)\n";
+		push(@xpdnames, $name);
+	}
+	return @xpdnames;
+}
+
+sub read_xpdnames($) {
+	my $xbus_num = shift || die;
+	my $xbus_dir = "$Dahdi::Xpp::sysfs_astribanks/xbus-$xbus_num";
+	my $pat = sprintf "%s/xbus-%02d/[0-9][0-9]:[0-9]:[0-9]", $Dahdi::Xpp::sysfs_astribanks, $xbus_num;
+	my @xpdnames;
+
+	#print STDERR "read_xpdnames($xbus_num): $pat\n";
+	foreach (glob $pat) {
+		die "Bad /sys entry: '$_'" unless m/^.*\/([0-9][0-9]):([0-9]):([0-9])$/;
+		my ($busnum, $unit, $subunit) = ($1, $2, $3);
+		my $name = sprintf("%02d:%1d:%1d", $1, $2, $3);
+		#print STDERR "\t> $_ ($name)\n";
+		push(@xpdnames, $name);
+	}
+	return @xpdnames;
+}
+
+my $warned_notransport = 0;
+
+sub new($$) {
+	my $pack = shift or die "Wasn't called as a class method\n";
+	my $num = shift;
+	my $xbus_dir = "$Dahdi::Xpp::sysfs_astribanks/xbus-$num";
+	my $self = {
+		NUM		=> $num,
+		NAME		=> "XBUS-$num",
+		SYSFS_DIR	=> $xbus_dir,
+		};
+	bless $self, $pack;
+	$self->read_attrs;
+	# Get transport related info
+	my $transport = "$xbus_dir/transport";
+	my $transport_type = $self->transport_type($xbus_dir);
+	if(defined $transport_type) {
+		my $tt = "Dahdi::Hardware::$transport_type";
+		my $hw = $tt->set_transport($self, $xbus_dir);
+		#printf STDERR "Xbus::new transport($transport_type): %s\n", $hw->{HARDWARE_NAME};
+	}
+	my @xpdnames;
+	my @xpds;
+	if(-e $transport) {
+		@xpdnames = read_xpdnames($num);
+	} else {
+		@xpdnames = read_xpdnames_old($num);
+		warn "$0: warning - OLD DRIVER: missing '$transport'. Fall back to /proc\n"
+			unless $warned_notransport++;
+	}
+	foreach my $xpdstr (@xpdnames) {
+		my ($busnum, $unit, $subunit) = split(/:/, $xpdstr);
+		my $procdir = "/proc/xpp/XBUS-$busnum/XPD-$unit$subunit";
+		my $xpd = Dahdi::Xpp::Xpd->new($self, $unit, $subunit, $procdir, "$xbus_dir/$xpdstr");
+		push(@xpds, $xpd);
+	}
+	@{$self->{XPDS}} = sort { $a->id <=> $b->id } @xpds;
+	return $self;
+}
+
+sub pretty_xpds($) {
+		my $xbus = shift;
+		my @xpds = sort { $a->id <=> $b->id } $xbus->xpds();
+		my @xpd_types = map { $_->type } @xpds;
+		my $last_type = '';
+		my $mult = 0;
+		my $xpdstr = '';
+		foreach my $curr (@xpd_types) {
+			if(!$last_type || ($curr eq $last_type)) {
+				$mult++;
+			} else {
+				if($mult == 1) {
+					$xpdstr .= "$last_type ";
+				} elsif($mult) {
+					$xpdstr .= "$last_type*$mult ";
+				}
+				$mult = 1;
+			}
+			$last_type = $curr;
+		}
+		if($mult == 1) {
+			$xpdstr .= "$last_type ";
+		} elsif($mult) {
+			$xpdstr .= "$last_type*$mult ";
+		}
+		$xpdstr =~ s/\s*$//;	# trim trailing space
+		return $xpdstr;
+}
+
+1;

Added: trunk/dahdi-gen/Dahdi/Xpp/Xpd.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Xpp/Xpd.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Xpp/Xpd.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,277 @@
+package Dahdi::Xpp::Xpd;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Xpd.pm 6647 2009-05-19 16:46:06Z tzafrir $
+#
+use strict;
+use Dahdi::Utils;
+use Dahdi::Xpp;
+use Dahdi::Xpp::Line;
+
+my %file_warned;	# Prevent duplicate warnings about same file.
+
+sub xpd_attr_path($@) {
+	my $self = shift || die;
+	my ($busnum, $unitnum, $subunitnum, @attr) = (
+		$self->xbus->num,
+		$self->unit,
+		$self->subunit,
+		@_);
+	foreach my $attr (@attr) {
+		my $file = sprintf "$Dahdi::Xpp::sysfs_xpds/%02d:%1d:%1d/$attr",
+		   $busnum, $unitnum, $subunitnum;
+		unless(-f $file) {
+			my $procfile = sprintf "/proc/xpp/XBUS-%02d/XPD-%1d%1d/$attr",
+			   $busnum, $unitnum, $subunitnum;
+			warn "$0: warning - OLD DRIVER: missing '$file'. Fall back to /proc\n"
+				unless $file_warned{$attr}++;
+			$file = $procfile;
+		}
+		next unless -f $file;
+		return $file;
+	}
+	return undef;
+}
+
+# Backward compat plug for old /proc interface...
+sub xpd_old_gettype($) {
+	my $xpd = shift || die;
+	my $summary = "/proc/xpp/" . $xpd->fqn . "/summary";
+	open(F, $summary) or die "Failed to open '$summary': $!";
+	my $head = <F>;
+	close F;
+	chomp $head;
+	$head =~ s/^XPD-\d+\s+\(//;
+	$head =~ s/,.*//;
+	return $head;
+}
+
+sub xpd_old_getspan($) {
+	my $xpd = shift || die;
+	my $dahdi_registration = "/proc/xpp/" . $xpd->fqn . "/dahdi_registration";
+	open(F, $dahdi_registration) or die "Failed to open '$dahdi_registration': $!";
+	my $head = <F>;
+	close F;
+	chomp $head;
+	return $head;
+}
+
+sub xpd_old_getoffhook($) {
+	my $xpd = shift || die;
+	my $summary = "/proc/xpp/" . $xpd->fqn . "/summary";
+	my $channels;
+
+	local $/ = "\n";
+	open(F, "$summary") || die "Failed opening $summary: $!\n";
+	my $head = <F>;
+	chomp $head;	# "XPD-00 (BRI_TE ,card present, span 3)"
+	my $offhook;
+	while(<F>) {
+		chomp;
+		if(s/^\s*offhook\s*:\s*//) {
+			s/\s*$//;
+			$offhook = $_;
+			$offhook || die "No channels in '$summary'";
+			last;
+		}
+	}
+	close F;
+	return $offhook;
+}
+
+my %attr_missing_warned;	# Prevent duplicate warnings
+
+sub xpd_driver_getattr($$) {
+	my $xpd = shift || die;
+	my $attr = shift || die;
+	$attr = lc($attr);
+	my ($busnum, $unitnum, $subunitnum) = ($xpd->xbus->num, $xpd->unit, $xpd->subunit);
+	my $file = sprintf "$Dahdi::Xpp::sysfs_xpds/%02d:%1d:%1d/driver/$attr",
+			$busnum, $unitnum, $subunitnum;
+	if(!defined($file)) {
+		warn "$0: xpd_driver_getattr($attr) -- Missing attribute.\n" if
+			$attr_missing_warned{$attr};
+		return undef;
+	}
+	open(F, $file) || return undef;
+	my $val = <F>;
+	close F;
+	chomp $val;
+	return $val;
+}
+
+sub xpd_getattr($$) {
+	my $xpd = shift || die;
+	my $attr = shift || die;
+	$attr = lc($attr);
+	my $file = $xpd->xpd_attr_path(lc($attr));
+
+	# Handle special cases for backward compat
+	return xpd_old_gettype($xpd) if $attr eq 'type' and !defined $file;
+	return xpd_old_getspan($xpd) if $attr eq 'span' and !defined $file;
+	return xpd_old_getoffhook($xpd) if $attr eq 'offhook' and !defined $file;
+	if(!defined($file)) {
+		warn "$0: xpd_getattr($attr) -- Missing attribute.\n" if
+			$attr_missing_warned{$attr};
+		return undef;
+	}
+	open(F, $file) || return undef;
+	my $val = <F>;
+	close F;
+	chomp $val;
+	return $val;
+}
+
+sub xpd_setattr($$$) {
+	my $xpd = shift || die;
+	my $attr = shift || die;
+	my $val = shift;
+	$attr = lc($attr);
+	my $file = xpd_attr_path($xpd, $attr);
+	my $oldval = $xpd->xpd_getattr($attr);
+	open(F, ">$file") or die "Failed to open $file for writing: $!";
+	print F "$val";
+	if(!close(F)) {
+		if($! == 17) {	# EEXISTS
+			# good
+		} else {
+			return undef;
+		}
+	}
+	return $oldval;
+}
+
+sub blink($$) {
+	my $self = shift;
+	my $on = shift;
+	my $result = $self->xpd_getattr("blink");
+	if(defined($on)) {		# Now change
+		$self->xpd_setattr("blink", ($on)?"0xFFFF":"0");
+	}
+	return $result;
+}
+
+sub dahdi_registration($$) {
+	my $self = shift;
+	my $on = shift;
+	my $result;
+	my $file = $self->xpd_attr_path("span", "dahdi_registration");
+	die "$file is missing" unless -f $file;
+	# First query
+	open(F, "$file") or die "Failed to open $file for reading: $!";
+	$result = <F>;
+	chomp $result;
+	close F;
+	if(defined($on) and $on ne $result) {		# Now change
+		open(F, ">$file") or die "Failed to open $file for writing: $!";
+		print F ($on)?"1":"0";
+		if(!close(F)) {
+			if($! == 17) {	# EEXISTS
+				# good
+			} else {
+				undef $result;
+			}
+		}
+	}
+	return $result;
+}
+
+sub xpds_by_spanno() {
+	my @xbuses = Dahdi::Xpp::xbuses();
+	my @xpds = map { $_->xpds } @xbuses;
+	@xpds = grep { $_->spanno } @xpds;
+	@xpds = sort { $a->spanno <=> $b->spanno } @xpds;
+	my @spanno = map { $_->spanno } @xpds;
+	my @idx;
+	@idx[@spanno] = @xpds;	# The spanno is the index now
+	return @idx;
+}
+
+sub new($$$$$) {
+	my $pack = shift or die "Wasn't called as a class method\n";
+	my $xbus = shift || die;
+	my $unit = shift;	# May be zero
+	my $subunit = shift;	# May be zero
+	my $procdir = shift || die;
+	my $sysfsdir = shift || die;
+	my $self = {
+		XBUS		=> $xbus,
+		ID		=> sprintf("%1d%1d", $unit, $subunit),
+		FQN		=> $xbus->name . "/" . "XPD-$unit$subunit",
+		UNIT		=> $unit,
+		SUBUNIT		=> $subunit,
+		DIR		=> $procdir,
+		SYSFS_DIR	=> $sysfsdir,
+		};
+	bless $self, $pack;
+	my @offhook = split / /, ($self->xpd_getattr('offhook'));
+	$self->{CHANNELS} = @offhook;
+	my $type = $self->xpd_getattr('type');
+	my $span = $self->xpd_getattr('span');
+	$self->{SPANNO} = $span;
+	$self->{TYPE} = $type;
+	if($type =~ /BRI_(NT|TE)/) {
+		$self->{IS_BRI} = 1;
+		$self->{TERMTYPE} = $1;
+		$self->{DCHAN_HARDHDLC} = $self->xpd_driver_getattr('dchan_hardhdlc');
+	}
+	$self->{IS_PRI} = ($type =~ /[ETJ]1/);
+	$self->{IS_DIGITAL} = ( $self->{IS_BRI} || $self->{IS_PRI} );
+	Dahdi::Xpp::Line->create_all($self, $procdir);
+	return $self;
+}
+
+#------------------------------------
+# static xpd related helper functions
+#------------------------------------
+
+sub sync_priority_rank($) {
+	my $xpd = shift || die;
+	# The @rank array is ordered by priority of sync (good to bad)
+	my @rank = (
+		($xpd->is_pri and defined($xpd->termtype) and $xpd->termtype eq 'TE'),
+		($xpd->is_bri and defined($xpd->termtype) and $xpd->termtype eq 'TE'),
+		($xpd->is_pri),
+		($xpd->type eq 'FXO'),
+		($xpd->is_bri),
+		($xpd->type eq 'FXS'),
+		);
+	for(my $i = 0; $i < @rank; $i++) {
+		return $i if $rank[$i];
+	}
+	return @rank + 1;
+}
+
+# An XPD sync priority comparator for sort()
+sub sync_priority_compare() {
+	my $rank_a = sync_priority_rank($a);
+	my $rank_b = sync_priority_rank($b);
+	#print STDERR "DEBUG: $rank_a (", $a->fqn, ") $rank_b (", $b->fqn, ")\n";
+	return $a->fqn cmp $b->fqn if $rank_a == $rank_b;
+	return $rank_a <=> $rank_b;
+}
+
+# For debugging: show a list of XPD's with relevant sync info.
+sub show_xpd_rank(@) {
+	print STDERR "XPD's by rank\n";
+	foreach my $xpd (@_) {
+		my $type = $xpd->type;
+		my $rank = sync_priority_rank($xpd);
+		if($xpd->is_digital) {
+			$type .= " (TERMTYPE " . ($xpd->termtype || "UNKNOWN") . ")";
+		}
+		printf STDERR "%3d %-15s %s\n", $rank, $xpd->fqn, $type;
+	}
+}
+
+sub xpds_by_rank(@) {
+	my @xpd_prio = sort sync_priority_compare @_;
+	#show_xpd_rank(@xpd_prio);
+	return @xpd_prio;
+}
+
+1;

Added: trunk/dahdi-gen/Dahdi/Xpp.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Xpp.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi/Xpp.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,337 @@
+package Dahdi::Xpp;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Xpp.pm 6313 2009-04-02 20:56:42Z tzafrir $
+#
+use strict;
+use Dahdi::Hardware;
+use Dahdi::Xpp::Xbus;
+
+=head1 NAME
+
+Dahdi::Xpp - Perl interface to the Xorcom Astribank drivers.
+
+=head1 SYNOPSIS
+
+  # Listing all Astribanks:
+  use Dahdi::Xpp;
+  # scans hardware:
+  my @xbuses = Dahdi::Xpp::xbuses("SORT_CONNECTOR");
+  for my $xbus (@xbuses) {
+    print $xbus->name." (".$xbus->label .", ". $xbus->connector .")\n";
+    for my $xpd ($xbus->xpds) {
+      print " - ".$xpd->fqn,"\n";
+    }
+  }
+=cut
+
+#
+# A global handle for all xbuses
+#
+my @xbuses;
+
+my $proc_base = "/proc/xpp";
+our $sysfs_astribanks = "/sys/bus/astribanks/devices";
+our $sysfs_xpds = "/sys/bus/xpds/devices";
+our $sysfs_ab_driver = "/sys/bus/astribanks/drivers/xppdrv";
+
+sub scan($) {
+	my $pack = shift || die;
+
+	opendir(D, $sysfs_astribanks) || return();
+	while(my $entry = readdir D) {
+		next unless $entry =~ /xbus-(\d+)/;
+		my $xbus = Dahdi::Xpp::Xbus->new($1);
+		push(@xbuses, $xbus);
+	}
+	closedir D;
+	return @xbuses;
+}
+
+# Nominal sorters for xbuses
+sub by_name {
+	return $a->name cmp $b->name;
+}
+
+sub by_connector {
+	return $a->connector cmp $b->connector;
+}
+
+sub by_label {
+	my $cmp = $a->label cmp $b->label;
+	return $cmp if $cmp != 0;
+	return $a->connector cmp $b->connector;
+}
+
+sub score_type {
+	my $score;
+
+	return 1 if grep(/\b[ETJ]1/, @_);
+	return 2 if grep(/\bBRI/, @_);
+	return 3 if grep(/\bFXO/, @_);
+	return 4;	# FXS
+}
+
+sub by_type {
+	my @a_types = map { $_->type } $a->xpds();
+	my @b_types = map { $_->type } $b->xpds();
+	my $res;
+
+	my $a_score = score_type(@a_types);
+	my $b_score = score_type(@b_types);
+	#printf STDERR "DEBUG-a: %s %s %s\n", $a->name, $a_score, join(',', at a_types);
+	#printf STDERR "DEBUG-b: %s %s %s\n", $b->name, $b_score, join(',', at b_types);
+	$res = $a_score <=> $b_score;
+	$res = $a->connector cmp $b->connector if $res == 0;
+	return $res;
+}
+
+sub by_xpporder {
+	my $cmp = $a->xpporder cmp $b->xpporder;
+	return $cmp if $cmp != 0;
+	return $a->connector cmp $b->connector;
+}
+
+=head1 xbuses([sort_order])
+
+Scans system (/proc and /sys) and returns a list of Astribank (Xbus) 
+objects. The optional parameter sort_order is the order in which 
+the Astribanks will be returns:
+
+
+=head1 sorters([sort_order])
+
+With no parameters, returns the names of built in sorters.
+With a single parameter, returns a reference to the requested built in sorter.
+Also, for convenience, a reference to a custom sorter function may be passed
+and returned as is.
+
+The built in sorters are:
+
+=over
+
+=item SORT_XPPORDER
+
+Sort by ordering defined in F</etc/dahdi/xpp_order> file.
+Astribanks can be listed in this file by their label or by
+their connector string (prefixed with <@>).
+
+Astribanks not listed in the F<xpp_order> file are sorted
+via ordering number 999 -- So they come after the Astribanks
+that are listed.
+
+Astribanks with same ordering number (e.g: 999) are sorted
+by their connector string (to preserve legacy behaviour).
+
+=item SORT_CONNECTOR
+
+Sort by the connector string. For USB this defines the "path" to get to
+the device through controllers, hubs etc.
+
+=item SORT_LABEL
+
+Sorts by the label of the Astribank. The label field is unique to the
+Astribank. It can also be viewed through 'lsusb -v' without the drivers
+loaded (the iSerial field in the Device Descriptor). This is normally
+relieble, but some older Astribanks have an empty label.
+
+=item SORT_NAME
+
+Sort by the "name". e.g: "XBUS-00". The order of Astribank names depends
+on the load order, and hence may change between different runs.
+
+=item SORT_TYPE
+
+Sort by XPD types. First Astribanks with E1/T1/J1 XPDs, then with BRI,
+then with FXO, then ones with only FXS ports. Within each type they
+are sorted by the connector field (as in SORT_CONNECTOR above).
+
+=item custom function
+
+Instead of using a predefined sorter, you can pass your own sorting
+function. See the example sorters in the code of this module.
+
+=back
+
+=cut
+
+sub sorters {
+	my %sorter_table = (
+		SORT_CONNECTOR	=> \&by_connector,
+		SORT_NAME	=> \&by_name,
+		SORT_LABEL	=> \&by_label,
+		SORT_TYPE	=> \&by_type,
+		SORT_XPPORDER	=> \&by_xpporder,
+		# Aliases
+		connector	=> \&by_connector,
+		name		=> \&by_name,
+		label		=> \&by_label,
+		type		=> \&by_type,
+		xpporder	=> \&by_xpporder,
+	);
+	my $which_sorter = shift || return sort keys %sorter_table;
+	return $which_sorter if ref($which_sorter) eq 'CODE';
+	return $sorter_table{$which_sorter};
+}
+
+sub add_xpporder(@) {
+	my @xbuses = @_;
+	my $cfg = $ENV{XPPORDER_CONF} || '/etc/dahdi/xpp_order';
+	my %order;
+
+	# Set defaults
+	foreach my $xbus (@xbuses) {
+		$xbus->{XPPORDER} = 99;
+	}
+	# Read from optional config file
+	if(!open(F, $cfg)) {
+		warn "$0: Failed opening '$cfg': $!"
+			unless $! == 2;		# ENOENT
+		return;
+	}
+	my $count = 1;
+	while(<F>) {
+		chomp;
+		s/#.*//;
+		s/^\s*//;
+		s/\s*$//;
+		next unless /\S/;
+		$order{$_} = $count++;
+	}
+	close F;
+	# Overrides from config file
+	foreach my $xbus (@xbuses) {
+		my $label = $xbus->label;
+		my $connector = '@' . $xbus->connector;
+		my $val;
+		$val = $order{$label};
+		$val = $order{$connector} unless defined $val;
+		$xbus->{XPPORDER} = $val if defined $val;
+	}
+}
+
+sub xbuses {
+	my $optsort = shift || 'SORT_XPPORDER';
+	my @sorted_xbuses;
+
+	if(! @xbuses) {
+		@xbuses = Dahdi::Xpp->scan();
+	}
+	add_xpporder(@xbuses);
+	my $sorter = sorters($optsort);
+	die "Unknown optional sorter '$optsort'" unless defined $sorter;
+	@sorted_xbuses = sort $sorter @xbuses;
+	return @sorted_xbuses;
+}
+
+sub xpd_of_span($) {
+	my $span = shift or die "Missing span parameter";
+	return undef unless defined $span;
+	foreach my $xbus (Dahdi::Xpp::xbuses) {
+		foreach my $xpd ($xbus->xpds()) {
+			return $xpd if $xpd->fqn eq $span->name;
+		}
+	}
+	return undef;
+}
+
+=head1 sync([new_sync_source])
+
+Gets (and optionally sets) the internal Astribanks synchronization
+source. When used to set sync source, returns the original sync source.
+
+A synchronization source is a value valid writing into /proc/xpp/sync .
+For more information read that file and see README.Astribank .
+
+=cut
+
+sub sync_via_proc {
+	my $newsync = shift;
+	my $result;
+	my $newapi = 0;
+
+	my $file = "$proc_base/sync";
+	return '' unless -f $file;
+	# First query
+	open(F, "$file") or die "Failed to open $file for reading: $!";
+	while(<F>) {
+		chomp;
+		/SYNC=/ and $newapi = 1;
+		s/#.*//;
+		if(/\S/) {	# First non-comment line
+			s/^SYNC=\D*// if $newapi;
+			$result = $_;
+			last;
+		}
+	}
+	close F;
+	if(defined($newsync)) {		# Now change
+		$newsync =~ s/.*/\U$&/;
+		if($newsync =~ /^(\d+)$/) {
+			$newsync = ($newapi)? "SYNC=$1" : "$1 0";
+		} elsif($newsync ne 'DAHDI') {
+			die "Bad sync parameter '$newsync'";
+		}
+		open(F, ">$file") or die "Failed to open $file for writing: $!";
+		print F $newsync;
+		close(F) or die "Failed in closing $file: $!";
+	}
+	return $result;
+}
+
+sub sync {
+	my ($newsync) = @_;
+	my $result;
+	my $file = "$sysfs_ab_driver/sync";
+	if(! -f $file) {	# Old /proc interface
+		return sync_via_proc(@_);
+	}
+	open(F, "$file") or die "Failed to open $file for reading: $!";
+	$result = <F>;
+	close F;
+	chomp $result;
+	$result =~ s/^SYNC=\D*//;
+	if(defined $newsync) {		# Now change
+		$newsync =~ s/.*/\U$&/;
+		if($newsync =~ /^(\d+)$/) {
+			$newsync = "SYNC=$1";
+		} elsif($newsync ne 'DAHDI') {
+			die "Bad sync parameter '$newsync'";
+		}
+		open(F, ">$file") or die "Failed to open $file for writing: $!";
+		print F $newsync;
+		close(F) or die "Failed in closing $file: $!";
+	}
+	return $result;
+}
+
+=head1 SEE ALSO
+
+=over
+
+=item L<Dahdi::Xpp::Xbus>
+
+Xbus (Astribank) object.
+
+=item L<Dahdi::Xpp::Xpd>
+
+XPD (the rough equivalent of a Dahdi span) object.
+
+=item L<Dahdi::Xpp::Line>
+
+Object for a line: an analog port or a time-slot in a adapter. 
+Equivalent of a channel in Dahdi.
+
+=item L<Dahdi>
+
+General documentation in the master package.
+
+=back
+
+=cut
+
+1;

Added: trunk/dahdi-gen/Dahdi.pm
===================================================================
--- trunk/dahdi-gen/Dahdi.pm	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/Dahdi.pm	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,69 @@
+package Dahdi;
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: Dahdi.pm 6579 2009-05-08 10:21:05Z tzafrir $
+#
+use strict;
+use Dahdi::Span;
+
+=head1 NAME
+
+Dahdi - Perl interface to Dahdi information
+
+This package allows access from Perl to information about Dahdi
+hardware and loaded Dahdi devices.
+
+=head1 SYNOPSIS
+
+  # Listing channels in analog spans:
+  use Dahdi;
+  # scans system:
+  my @spans = Dahdi::spans();
+  for my $span (@spans) {
+    next if ($span->is_digital);
+     $span->num. " - [". $span->type ."] ". $span->name. "\n";
+    for my $chan ($span->chans) {
+      print " - ".$chan->num . " - [". $chan->type. "] ". $chan->fqn". \n";
+    }
+  }
+=cut
+
+my $proc_base = "/proc/dahdi";
+
+=head1 spans()
+
+Returns a list of span objects, ordered by span number.
+
+=cut
+
+sub spans() {
+	my @spans;
+
+	-d $proc_base or return ();
+	foreach my $zfile (glob "$proc_base/*") {
+		$zfile =~ s:$proc_base/::;
+		next unless ($zfile =~ /^\d+$/);
+		my $span = Dahdi::Span->new($zfile);
+		push(@spans, $span);
+	}
+	@spans = sort { $a->num <=> $b->num } @spans;
+	return @spans;
+}
+
+=head1 SEE ALSO
+
+Span objects: L<Dahdi::Span>.
+
+Dahdi channels objects: L<Dahdi::Chan>.
+
+Dahdi hardware devices information: L<Dahdi::Hardware>.
+
+Xorcom Astribank -specific information: L<Dahdi::Xpp>.
+
+=cut
+
+1;

Added: trunk/dahdi-gen/dahdi_genconf
===================================================================
--- trunk/dahdi-gen/dahdi_genconf	2009-12-20 19:42:40 UTC (rev 854)
+++ trunk/dahdi-gen/dahdi_genconf	2009-12-20 21:44:13 UTC (rev 855)
@@ -0,0 +1,196 @@
+#! /usr/bin/perl -w
+#
+# Written by Oron Peled <oron at actcom.co.il>
+# Copyright (C) 2007, Xorcom
+# This program is free software; you can redistribute and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: dahdi_genconf 6647 2009-05-19 16:46:06Z tzafrir $
+#
+use strict;
+use File::Basename;
+BEGIN { my $dir = dirname($0); unshift(@INC, "$dir"); }
+
+use Getopt::Std;
+use Dahdi;
+use Dahdi::Xpp;
+use Dahdi::Config::Gen;
+use Dahdi::Config::Params;
+
+my $version = '1';	# Functionality version (integer)
+my $revision = '$Revision: 6647 $';
+
+my %opts;
+
+sub set_defaults {
+	my $default_file = $ENV{GENCONF_PARAMETERS} || "/etc/dahdi/genconf_parameters";
+	my $params = Dahdi::Config::Params->new($default_file);
+	#$params->dump;
+	if($opts{v}) {
+		print "Default parameters from ", $params->{GENCONF_FILE}, "\n";
+	}
+	my $gconfig = Dahdi::Config::Gen->new($params);
+	#$gconfig->dump;
+	return $gconfig;
+}
+
+sub spans_prep($@) {
+	my $gconfig = shift || die;
+	my @spans = @_;
+	foreach my $span (@spans) {
+		if($span->is_pri) {
+			$span->pri_set_fromconfig($gconfig);
+		}
+	}
+}
+
+sub generator_list($) {
+	my $gconfig = shift || die;
+	my @genlist;
+
+	if (@ARGV) {
+		for my $gen (@ARGV) {
+			push @genlist, $gen;
+		}
+	} else {
+		# No files given. Use the defaults.
+		@genlist = ('system', 'chandahdi');
+		if($gconfig->{'pri_connection_type'} eq 'R2') {
+			push @genlist, 'unicall';
+		}
+	}
+	return @genlist;
+}
+
+sub parse_genopts($) {
+	my $optstr = shift;
+	my %genopts;
+
+	$optstr = '' unless defined $optstr;
+	foreach my $o (split(/,/, $optstr)) {
+		my ($k, $v) = split(/=/, $o, 2);
+		$v = 1 unless defined $v and $v;
+		$genopts{$k} = $v;
+	}
+	return %genopts;
+}
+
+sub generate_files($@) {
+	my $gconfig = shift || die;
+	my @spans = @_;
+	my @generators = generator_list($gconfig);
+
+	for my $gen (@generators) {
+		my ($name, $optstr) = split(/=/, $gen, 2);
+		die "Illegal name '$name'\n" unless $name =~ /^\w+$/;
+		$name =~ s/(.)(.*)/\u$1\L$2/;
+		my %genopts = parse_genopts($optstr);
+		$genopts{'freepbx'} = 'yes' if $opts{'F'};
+		if(defined $opts{'v'}) {
+			$genopts{'verbose'} = $opts{v};
+		}
+		$gconfig->run_generator($name, \%genopts, @spans);
+	}
+}
+
+getopts('vVF', \%opts) || die "$0: Bad option\n";
+if($opts{'V'}) {
+	my $revstr = $revision;
+	$revstr =~ s/[^$]*\$[^:]+:\s*//;
+	$revstr =~ s/\s*\$.*//;
+	print "$0: version=$version revision=$revstr\n";
+	exit 0;
+}
+
+my $gconfig = set_defaults;
+my @spans = Dahdi::spans();
+spans_prep($gconfig, @spans);
+generate_files($gconfig, @spans);
+
+__END__
+
+=head1 NAME
+
+dahdi_genconf - Generate configuration for dahdi channels.
+
+=head1 SYNOPSIS
+
+dahdi_genconf [options] [generator...]
+
+=head1 DESCRIPTION
+
+This script generate configuration files for Dahdi hardware.
+It uses two information sources:
+
+=over 4
+
+=item Hardware
+
+ The actual dahdi hardware is automatically detected on the host.
+
+=item /etc/dahdi/genconf_parameters
+
+A configuration file that supplements the hardware information.
+Its location may be overriden via the C<GENCONF_PARAMETERS> environment
+variable.
+
+=back
+
+The dahdi_genconf script can generate various kinds of configuration files
+as specificed by the generator arguments.  Each generator is a perl classes
+in Dahdi::Config::Gen namespace.  The generator names on the command line
+are the class names in lowercase.
+
+The following generators are currently implemented: system, chandahdi, unicall, users.
+For further documentation on each, please user perldoc on the relevant
+class. E.g: C<perldoc Dahdi::Config::Gen::Chandahdi>
+
+Each generator on the command line may be passed custom options by assigning
+a comma separated list of options to the generator name. E.g:
+
+ dahdi_genconf system chandahdi=verbose unicall
+
+=head2 Global options:
+
+=over 4
+
+=item -V
+
+Version -- print version string and exit.
+
+=item -v
+
+Verbose -- sets the C<'verbose'> option for all generators.
+
+=item -F
+
+Freepbx -- sets the C<'freepbx'> option for all generators.
+Currently, chandahdi is affected.
+
+
+=back
+
+=head2 Implementation notes:
+
+=over 4
+
+=item *
+
+F<genconf_parameters> parsing is done via C<Dahdi::Config::Params>.
+An object representing the parsed data is instanciated by:
+C<Dahdi::Config::Params-E<gt>new()>.
+The C<item()> method of this object contains all the hard coded
+defaults of the configuration directives.
+
+=item *
+
+A configuration object is instanciated by C<Dahdi::Config::Gen-E<gt>new($params)>.
+The mapping of configuration directives into semantic configuration is
+done in the constructor.
+
+=item *
+
+A single generator is run via the the C<run_generator()> method of the
+configuration object.
+
+=back


Property changes on: trunk/dahdi-gen/dahdi_genconf
___________________________________________________________________
Name: svn:executable
   + *



From alerios at mail.berlios.de  Sun Dec 20 23:27:01 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 23:27:01 +0100
Subject: [Destar-dev] r856 - trunk
Message-ID: <200912202227.nBKMR1Lv010244@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 23:27:00 +0100 (Sun, 20 Dec 2009)
New Revision: 856

Added:
   trunk/page_admin_autodetect.ptl
Modified:
   trunk/CHANGELOG.txt
   trunk/backend.py
Log:
* Added  page_admin_autodetect - needs more testing.


Modified: trunk/CHANGELOG.txt
===================================================================
--- trunk/CHANGELOG.txt	2009-12-20 21:44:13 UTC (rev 855)
+++ trunk/CHANGELOG.txt	2009-12-20 22:27:00 UTC (rev 856)
@@ -12,8 +12,9 @@
 * cfg_opt_user.py: Added SAMBA_ENABLED option.
 * Added sambautils.py
 * cfg_phone_zap.py: added missing monitorinbound variable.
-* Added dahdi-gen and created dahdi-gen/Dahdi/Config/Gen/Destar.pm
-  as a proof-of-concept (thanks tzafrir).
+* Added  page_admin_autodetect, dahdi-gen and created
+  dahdi-gen/Dahdi/Config/Gen/Destar.pm as a
+  proof-of-concept (thanks tzafrir) - needs more testing.
 
 2009-12-16
 * cfg_opt_pbx.py, cfg_app_*: separate context for all apps.

Modified: trunk/backend.py
===================================================================
--- trunk/backend.py	2009-12-20 21:44:13 UTC (rev 855)
+++ trunk/backend.py	2009-12-20 22:27:00 UTC (rev 856)
@@ -916,3 +916,24 @@
 	for c in configletsList():
 		cfg = globals()[c.__name__](autoAdd=False)
 		cfg.writeDoc()
+
+def dahdigenconf():
+	"""This calls dahdi_genconf."""
+	dahdi_genconf = commands.getoutput('dahdi_genconf system destar')
+	if dahdi_genconf:
+		fn = os.path.join(configlets.CONF_DIR,"destar_channels.py")
+		try:
+			try:
+				reload(sys)
+				sys.setdefaultencoding('utf-8')
+				execfile(fn)
+			except IOError:
+				try:
+					execfile(DESTAR_CFG)
+				except IOError:
+					print _("Warning: There is no %s or %s file yet." % (fn,DESTAR_CFG))
+		except NameError:
+			pass
+		return True
+	else:
+		return False

Added: trunk/page_admin_autodetect.ptl
===================================================================
--- trunk/page_admin_autodetect.ptl	2009-12-20 21:44:13 UTC (rev 855)
+++ trunk/page_admin_autodetect.ptl	2009-12-20 22:27:00 UTC (rev 856)
@@ -0,0 +1,66 @@
+# -*- coding: utf-8 -*-
+#
+# Copyright (C) 2005 by Holger Schurig
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+
+
+from Templates import *
+import backend
+import manager
+from quixote.directory import Directory, AccessControlled
+from quixote import get_request, get_session
+
+class Page(AccessControlled, Directory): 
+
+
+	_q_parent  = 'page_admin'
+	_q_title   = _("Autodetect Dahdi channels")
+	_q_desc    = _("Uses dahdi_genconf to autodetect channels and create DeStar's trunks")
+	_q_link    = 'genconf'
+	_q_menupos = 90
+	_q_level   = 3
+
+	_q_exports = ['']
+
+	def _q_access(self):
+		self.session = get_session()
+		self.request = get_request()
+		if self.session.level < self._q_level:
+			cantAccessPage()
+
+	def _q_index [html] (self):
+		header(self._q_desc)
+		manager.connect()
+		if not manager.isConnected():
+			'<p><span class="errornotice">'
+			_("Asterisk is not running!")
+			'</span></p>'
+		elif not manager.isLoggedIn():
+			# TODO: describe how to set this up
+			'<p><span class="errornotice">'
+			_("The manager access is not working!")
+			'</span></p>'
+		else:
+			'<p>'
+			_('Doing a reload, result is:')
+			'</p>'
+
+			'<tt><p>'
+			backend.dahdigenconf()
+			'</p></tt>'
+
+		footer()



From alerios at mail.berlios.de  Sun Dec 20 23:28:33 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Sun, 20 Dec 2009 23:28:33 +0100
Subject: [Destar-dev] r857 - trunk
Message-ID: <200912202228.nBKMSXHU010879@sheep.berlios.de>

Author: alerios
Date: 2009-12-20 23:28:33 +0100 (Sun, 20 Dec 2009)
New Revision: 857

Modified:
   trunk/page_admin_autodetect.ptl
Log:
Added "beta" warning to page_admin_autodetect.ptl


Modified: trunk/page_admin_autodetect.ptl
===================================================================
--- trunk/page_admin_autodetect.ptl	2009-12-20 22:27:00 UTC (rev 856)
+++ trunk/page_admin_autodetect.ptl	2009-12-20 22:28:33 UTC (rev 857)
@@ -28,8 +28,9 @@
 
 
 	_q_parent  = 'page_admin'
-	_q_title   = _("Autodetect Dahdi channels")
-	_q_desc    = _("Uses dahdi_genconf to autodetect channels and create DeStar's trunks")
+	_q_title   = _("Autodetect Dahdi channels (beta)")
+	_q_desc    = _("Uses dahdi_genconf to autodetect channels and create DeStar's trunks\
+			Warning: this is beta and could break your current config.")
 	_q_link    = 'genconf'
 	_q_menupos = 90
 	_q_level   = 3



From alerios at mail.berlios.de  Mon Dec 21 05:19:05 2009
From: alerios at mail.berlios.de (alerios at BerliOS)
Date: Mon, 21 Dec 2009 05:19:05 +0100
Subject: [Destar-dev] r858 - in trunk: . dahdi-gen/Dahdi/Config
	dahdi-gen/Dahdi/Config/Gen
Message-ID: <200912210419.nBL4J5pr020640@sheep.berlios.de>

Author: alerios
Date: 2009-12-21 05:19:03 +0100 (Mon, 21 Dec 2009)
New Revision: 858

Modified:
   trunk/backend.py
   trunk/cfg_trunk_zappri.py
   trunk/dahdi-gen/Dahdi/Config/Gen.pm
   trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm
   trunk/page_admin_autodetect.ptl
Log:
* Dahdi E1 trunks autodetection almost ready.


Modified: trunk/backend.py
===================================================================
--- trunk/backend.py	2009-12-20 22:28:33 UTC (rev 857)
+++ trunk/backend.py	2009-12-21 04:19:03 UTC (rev 858)
@@ -316,7 +316,7 @@
 	c.setSection(context)
 	c.appendExten("s", "Answer()", context)
 	c.appendExten("s", "Wait(${ARG2})", context)
-	c.appendExten("s", "Set(LOCALSTATIONID=%s)" getSetting('header_text', 'DeStar PBX'), context)
+	c.appendExten("s", "Set(LOCALSTATIONID=%s)" % getSetting('header_text', 'DeStar PBX'), context)
 	c.appendExten("s", "SendFAX(${FAXFILE})", context)
 	c.appendExten("s", "Hangup", context)
 	c.appendExten("h", "NoOp(TX: REMOTESTATIONID is ${REMOTESTATIONID})", context)
@@ -919,8 +919,8 @@
 
 def dahdigenconf():
 	"""This calls dahdi_genconf."""
-	dahdi_genconf = commands.getoutput('dahdi_genconf system destar')
-	if dahdi_genconf:
+	dahdi_genconf = commands.getoutput('dahdi_genconf system destar').split("\n")
+	if dahdi_genconf[0] != "Empty configuration -- no spans":
 		fn = os.path.join(configlets.CONF_DIR,"destar_channels.py")
 		try:
 			try:
@@ -929,11 +929,14 @@
 				execfile(fn)
 			except IOError:
 				try:
-					execfile(DESTAR_CFG)
+					execfile("dahdi-gen/destar_channels.py")
 				except IOError:
-					print _("Warning: There is no %s or %s file yet." % (fn,DESTAR_CFG))
+					print _("Warning: There is no %s or %s file yet." % (fn,"dahdi-gen/destar_channels.py"))
+					return False
 		except NameError:
 			pass
+		fixupConfiglets()
+		createPythonConfig()
 		return True
 	else:
 		return False

Modified: trunk/cfg_trunk_zappri.py
===================================================================
--- trunk/cfg_trunk_zappri.py	2009-12-20 22:28:33 UTC (rev 857)
+++ trunk/cfg_trunk_zappri.py	2009-12-21 04:19:03 UTC (rev 858)
@@ -74,6 +74,15 @@
 				type="string",
 				optional=True),
 
+			VarType("dialmethod",
+				title=_("Dial Group Method: G/g/R/r"),
+				type="choice",
+				options=[('g',_('g: Ascending sequential hunt group')),
+					('G', _('G: Descending sequential hunt group')),
+					('r', _('r: Ascending rotary hunt group')),
+					('R', _('R: Descending rotary hunt group'))],
+				default="g"),
+
 			VarType("panelLab",
 				title=_("Operator Panel"),
 				type="label",
@@ -165,32 +174,32 @@
 					message = _("This is a Dependency"))
 		]
 
-	def isAddable(self):
-		"""We can only add this configlet if we have at least one
-		DAHDIPRI option defined."""
+#	def isAddable(self):
+#		"""We can only add this configlet if we have at least one
+#		DAHDIPRI option defined."""
+#
+#		# BUG: it does somehow not work to simply write for obj in config_entries,
+#		# despite the "from configlets import *" above
+#		import configlets
+#		for obj in configlets.configlet_tree:
+#			if obj.__class__.__name__ == 'CfgOptDAHDIPRI':
+#				return True
+#		return False 
+#	isAddable = classmethod(isAddable)
 
-		# BUG: it does somehow not work to simply write for obj in config_entries,
-		# despite the "from configlets import *" above
-		import configlets
-		for obj in configlets.configlet_tree:
-			if obj.__class__.__name__ == 'CfgOptDAHDIPRI':
-				return True
-		return False 
-	isAddable = classmethod(isAddable)
-
 	def checkConfig(self):
                 res = CfgTrunk.checkConfig(self)
                 if res:
                         return res
-		import configlets
-		for obj in configlets.configlet_tree:
-			if obj.__class__.__name__ == 'CfgTrunkDAHDIPRI':
-				if obj==self: continue
-				try:
-					if obj.group == self.group and obj.group:
-						return ("group", _("Group already in use"))
-				except AttributeError:
-					pass
+		#import configlets
+		#for obj in configlets.configlet_tree:
+		#	if obj.__class__.__name__ == 'CfgTrunkDAHDIPRI':
+		#		if obj==self: continue
+		#		try:
+		#			if obj.group == self.group and obj.group:
+		#				return ("group", _("Group already in use"))
+		#		except AttributeError:
+		#			pass
 
 
 	def fixup(self):
@@ -212,6 +221,8 @@
 			c.appendValue(self, "group")
 		c.appendValue(self, "signalling")
 		c.appendValue(self, "switchtype")
+		c.append("resetinterval=never")
+		c.append("prilocaldialplan=local")
 		c.appendValue(self, "pridialplan")
 		contextin = "in-%s" % self.name
 		c.append("context=%s" % contextin)
@@ -238,7 +249,7 @@
 
 		#Dial part to use on dialout macro
 		if self.group:
-			self.dial = "DAHDI/g%s/${ARG1}" % (self.group)
+                        self.dial = "DAHDI/%s%s/${ARG1}" % (self.dialmethod, self.group)
 		else:
 			self.dial = "DAHDI/%s/${ARG1}" % (self.channels)
 		

Modified: trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm	2009-12-20 22:28:33 UTC (rev 857)
+++ trunk/dahdi-gen/Dahdi/Config/Gen/Destar.pm	2009-12-21 04:19:03 UTC (rev 858)
@@ -62,11 +62,9 @@
 	my $type = $span->type() || die "$0: Span #$num -- unkown type\n";
 	my $termtype = $span->termtype() || die "$0: Span #$num -- unkown termtype [NT/TE]\n";
 	my $group = $gconfig->{'group'}{"$type"};
-	my $context = $gconfig->{'context'}{"$type"};
-	my @to_reset = qw/context group/;
+	my @to_reset = qw/group/;
 
 	die "$0: missing default group (termtype=$termtype)\n" unless defined($group);
-	die "$0: missing default context\n" unless $context;
 
 	my $sig = $span->signalling || die "missing signalling info for span #$num type $type";
 	grep($gconfig->{'bri_sig_style'} eq $_, 'bri', 'bri_ptmp', 'pri') or die "unknown signalling style for BRI";

Modified: trunk/dahdi-gen/Dahdi/Config/Gen.pm
===================================================================
--- trunk/dahdi-gen/Dahdi/Config/Gen.pm	2009-12-20 22:28:33 UTC (rev 857)
+++ trunk/dahdi-gen/Dahdi/Config/Gen.pm	2009-12-21 04:19:03 UTC (rev 858)
@@ -173,6 +173,7 @@
 	#print STDERR "DEBUG: $module\n";
 	eval "use $module";
 	if($@) {
+		print $@;
 		die "Failed to load configuration generator for '$name'\n";
 	}
 	my $cfg = $module->new($gconfig, $genopts);

Modified: trunk/page_admin_autodetect.ptl
===================================================================
--- trunk/page_admin_autodetect.ptl	2009-12-20 22:28:33 UTC (rev 857)
+++ trunk/page_admin_autodetect.ptl	2009-12-21 04:19:03 UTC (rev 858)
@@ -20,7 +20,6 @@
 
 from Templates import *
 import backend
-import manager
 from quixote.directory import Directory, AccessControlled
 from quixote import get_request, get_session
 
@@ -45,23 +44,11 @@
 
 	def _q_index [html] (self):
 		header(self._q_desc)
-		manager.connect()
-		if not manager.isConnected():
-			'<p><span class="errornotice">'
-			_("Asterisk is not running!")
-			'</span></p>'
-		elif not manager.isLoggedIn():
-			# TODO: describe how to set this up
-			'<p><span class="errornotice">'
-			_("The manager access is not working!")
-			'</span></p>'
-		else:
-			'<p>'
-			_('Doing a reload, result is:')
-			'</p>'
+		'<p>'
+		_('Doing a reload, result is:')
+		'</p>'
 
-			'<tt><p>'
-			backend.dahdigenconf()
-			'</p></tt>'
-
+		'<tt><p>'
+		backend.dahdigenconf()
+		'</p></tt>'
 		footer()



